var documenterSearchIndex = {"docs":
[{"location":"api/#api","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Main-Functions","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api/#Schrieffer-Wolff-Transformation","page":"API Reference","title":"Schrieffer-Wolff Transformation","text":"","category":"section"},{"location":"api/#Magnus-Expansion-(Floquet-Systems)","page":"API Reference","title":"Magnus Expansion (Floquet Systems)","text":"","category":"section"},{"location":"api/#Subspace-Definition","page":"API Reference","title":"Subspace Definition","text":"","category":"section"},{"location":"api/#Hamiltonian-Decomposition","page":"API Reference","title":"Hamiltonian Decomposition","text":"","category":"section"},{"location":"api/#Generator-Solution","page":"API Reference","title":"Generator Solution","text":"The core operation in Schrieffer-Wolff is solving S H_d = -V_od for the generator S.","category":"section"},{"location":"api/#Main-Function","page":"API Reference","title":"Main Function","text":"","category":"section"},{"location":"api/#Method-Specific-Functions","page":"API Reference","title":"Method-Specific Functions","text":"Two methods are available, automatically selected based on the operator types:\n\nThe eigenoperator method works when H_d O = varepsilon cdot O (TLS, bosons, N-level transitions).\n\nThe Lie algebra method works for SU(N) systems by converting to the Cartan-Weyl basis where generators become eigenoperators.","category":"section"},{"location":"api/#Supporting-Functions","page":"API Reference","title":"Supporting Functions","text":"","category":"section"},{"location":"api/#Projection","page":"API Reference","title":"Projection","text":"","category":"section"},{"location":"api/#Projection-with-Symbolic-Sums","page":"API Reference","title":"Projection with Symbolic Sums","text":"The project_to_subspace function supports SymExpr, SymSum, and SymProd types for multi-atom systems:\n\nusing QuantumAlgebra, UnitaryTransformations\nimport QuantumAlgebra: sumindex, SymSum, SymExpr\n\ni = sumindex(1)\nH_eff = SymExpr(ω_c * a'()*a()) + SymSum(Δ/2 * σz(i), i)\n\nP = Subspace(a'()*a() => 0, σz() => -1)\nH_P = project_to_subspace(H_eff, P)\n# σz(i) → -1 for spin-down subspace\n# Symbolic sums are preserved in the result\n\nSupported types:\n\nQuExpr — standard quantum expressions\nSymSum — symbolic sums over site indices\nSymProd — symbolic products over site indices  \nSymExpr — combinations of the above\n\n","category":"section"},{"location":"api/#BCH-Expansion","page":"API Reference","title":"BCH Expansion","text":"The Baker-Campbell-Hausdorff expansion is used to compute e^S H e^-S.\n\n","category":"section"},{"location":"api/#Symbolic-Utilities","page":"API Reference","title":"Symbolic Utilities","text":"","category":"section"},{"location":"api/#Coefficient-Manipulation","page":"API Reference","title":"Coefficient Manipulation","text":"","category":"section"},{"location":"api/#Simplification-Modes","page":"API Reference","title":"Simplification Modes","text":"The simplify_coefficients function supports several modes for different speed/quality trade-offs:\n\nMode Description Speed\n:none No simplification Fastest\n:fast Expansion only (flattens nested expressions) Fast (default)\n:standard Full algebraic simplification with expansion Moderate\n:fractions Simplify rational expressions with GCD Slow\n:aggressive Maximum simplification Slowest\n\n# For exploration and debugging (fastest)\nresult = schrieffer_wolff(H, P; order=4, simplify_mode=:none)\n\n# For final results (default, good balance)\nresult = schrieffer_wolff(H, P; order=4, simplify_mode=:fast)\n\n# For publication-ready expressions\nH_simplified = simplify_coefficients(result.H_P; mode=:standard)","category":"section"},{"location":"api/#LaTeX-Output","page":"API Reference","title":"LaTeX Output","text":"","category":"section"},{"location":"api/#Parameter-Conversion","page":"API Reference","title":"Parameter Conversion","text":"Functions for converting between QuantumAlgebra's Param and Symbolics.jl variables:\n\n","category":"section"},{"location":"api/#Re-exported-from-QuantumAlgebra","page":"API Reference","title":"Re-exported from QuantumAlgebra","text":"The following functions are re-exported for convenience:\n\ncomm(A, B) - Compute commutator A B = AB - BA\nnormal_form(expr) - Normal-order an operator expression\na(), a'() - Bosonic annihilation/creation operators\nσx(), σy(), σz() - Pauli matrices\nσp(), σm() - Raising/lowering operators (when use_σpm(true))\nnlevel_ops(N, name) - N-level transition operators iranglelangle j\nsu_generators(N, name) - SU(N) generators (generalized Gell-Mann matrices)\n\n","category":"section"},{"location":"api/#Symbolic-Parameters","page":"API Reference","title":"Symbolic Parameters","text":"Use Symbolics.jl @variables to define symbolic parameters:\n\nusing Symbolics\n@variables Δ g ω  # Define symbolic parameters\n\nFor N-level systems with indexed parameters:\n\n# Create ω₁, ω₂, ..., ωₙ\nω = [Symbolics.variable(Symbol(\"ω\", i)) for i in 1:N]\n\n","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#SWResult","page":"API Reference","title":"SWResult","text":"The schrieffer_wolff function returns a named tuple:\n\nresult = schrieffer_wolff(H, P; order=2)\n\nresult.S      # Generator of the transformation\nresult.H_eff  # Block-diagonal effective Hamiltonian  \nresult.H_P    # H_eff projected onto subspace P","category":"section"},{"location":"api/#Subspace","page":"API Reference","title":"Subspace","text":"# Single constraint\nP = Subspace(σz() => -1)\n\n# Multiple constraints\nP = Subspace(σz() => -1, a'()*a() => 0)\n\n# N-level constraint\nP = Subspace(a'()*a() => 0)  # zero photons","category":"section"},{"location":"api/#Classification-Enums","page":"API Reference","title":"Classification Enums","text":"The package uses classification enums for operator analysis:\n\nDIAGONAL   # Operator preserves the subspace\nRAISING    # Operator raises out of subspace P\nLOWERING   # Operator lowers into subspace P\nMIXED      # Operator has mixed character\n\n","category":"section"},{"location":"api/#Performance-Tips","page":"API Reference","title":"Performance Tips","text":"","category":"section"},{"location":"api/#Parallel-Computation","page":"API Reference","title":"Parallel Computation","text":"For high-order SW transformations, enable multi-threading:\n\n# Start Julia with 4 threads\njulia -t 4\n\n# Enable parallel BCH term computation\nresult = schrieffer_wolff(H, P; order=5, parallel=true)","category":"section"},{"location":"api/#Benchmarks-(Jaynes-Cummings-model,-4-threads)","page":"API Reference","title":"Benchmarks (Jaynes-Cummings model, 4 threads)","text":"Order simplify_mode=:none simplify_mode=:fast\n4 0.4 s 0.6 s\n5 1.7 s 1.7 s\n6 50 s 80 s","category":"section"},{"location":"api/#Recommended-Workflow","page":"API Reference","title":"Recommended Workflow","text":"Explore with simplify_mode=:none for speed\nVerify with simplify_mode=:fast (default)\nSimplify for publication with simplify_coefficients(expr; mode=:standard)\n\n","category":"section"},{"location":"api/#Internal-Functions","page":"API Reference","title":"Internal Functions","text":"These functions are not exported but may be useful for advanced users:","category":"section"},{"location":"api/#Lie-Algebra-Support","page":"API Reference","title":"Lie Algebra Support","text":"# Get generators for detected Lie algebra\nget_generators_for_lie_system(lie_info::NamedTuple)\n\n# Convert between bases\ngellmann_to_cartan_weyl(V_od, N, algebra_id)\ncartan_weyl_to_gellmann(transitions, N, generators)","category":"section"},{"location":"api/#Operator-Classification","page":"API Reference","title":"Operator Classification","text":"# Classify a single term\nclassify_term(term::QuTerm, coeff, constraints)\n\n# Check if operator contains only specific types\nhas_only_bosons(term::QuTerm)\nhas_only_tls(term::QuTerm)","category":"section"},{"location":"api/#UnitaryTransformations.schrieffer_wolff","page":"API Reference","title":"UnitaryTransformations.schrieffer_wolff","text":"schrieffer_wolff(H::QuExpr, P::Subspace; order::Int=2)\n\nPerform the Schrieffer-Wolff transformation on Hamiltonian H with respect  to the low-energy subspace P.\n\nThe transformation finds a unitary U = e^S such that H_eff = e^S H e^{-S} is block-diagonal with respect to P and Q = 1-P, up to the specified order in perturbation theory.\n\nArguments\n\nH: The full Hamiltonian to transform\nP: The low-energy subspace definition\norder: Perturbation theory order in the coupling strength (default: 2).\norder=2: Standard SW, captures g² corrections (dispersive shifts)\norder=4: Includes g⁴ corrections (Kerr nonlinearity, Bloch-Siegert, etc.)\nsimplify_generator: Whether to simplify the generator S (default: false). Simplifying S can be slow at high orders. Set to true if you need simplified S.\nsimplify_mode: Simplification mode for final output (default: :fast).\n:none - No simplification (fastest)\n:fast - Expansion only (default, very fast, recommended)\n:standard - Basic algebraic simplification with expansion\n:fractions - Simplify fractions with GCD (slow on complex expressions)\n:aggressive - Full simplification (slowest)\ndiagonal_only: If true, only compute H_eff (skip computing higher-order generators). This is much faster for high orders when you only need the effective Hamiltonian. Note: This uses a simplified algorithm that only uses S₁.\nparallel: If true, use multi-threading for orders > 3 (default: false). Requires Julia to be started with multiple threads (e.g., julia -t 4). For best performance, use 4-8 threads; more threads can cause lock contention. Parallelization is most beneficial for orders 4-6 with complex Hamiltonians.\n\nReturns\n\nNamed tuple (H_eff, S, H_P) where:\nH_eff: The full block-diagonal effective Hamiltonian\nS: The generator of the transformation (S = S₁ + S₂ + ... where Sₙ is O(gⁿ))     Note: If diagonal_only=true, S contains only S₁.\nH_P: The effective Hamiltonian projected onto subspace P\n\nAlgorithm\n\nThe SW transformation uses S = S₁ + S₂ + S₃ + ... where each Sₙ is order gⁿ. At each order, the off-diagonal terms from the BCH expansion determine Sₙ, and the diagonal terms contribute to H_eff.\n\nKey commutator rules (D=diagonal, O=off-diagonal):\n\n[O, O] → D\n[O, D] → O  \n[D, D] → D\n\nExample\n\nusing QuantumAlgebra, UnitaryTransformations, Symbolics\n\n# Jaynes-Cummings in dispersive regime\n@variables ω Δ g  # ω = cavity frequency, Δ = qubit splitting, g = coupling strength\n\nH = ω * a'()*a() + Δ/2 * σz() + g * (a'()*σm() + a()*σp())\n\n# Transform to eliminate qubit-photon coupling\nP = Subspace(σz() => -1)  # qubit ground state\nresult = schrieffer_wolff(H, P; order=2)\n\n# For 4th order corrections (Kerr effect, etc.) - parallel computation\nresult4 = schrieffer_wolff(H, P; order=4, parallel=true)\n\n\n\n\n\nschrieffer_wolff(H::SymExpr, P::Subspace; order::Int=2, ...)\n\nPerform the Schrieffer-Wolff transformation on a Hamiltonian expressed with symbolic sums (SymExpr).\n\nThis extends the standard SW transformation to handle Hamiltonians like the Tavis-Cummings model:\n\nH = ω_c a†a + Σᵢ (Δ/2)σz(i) + Σᵢ g(a†σ⁻(i) + aσ⁺(i))\n\nThe key capability is correct handling of:\n\nSame-site contributions: Σᵢ [Aᵢ, Bᵢ]\nCross-site contributions: Σᵢ Σⱼ≠ᵢ [Aᵢ, Bⱼ] (exchange interactions)\n\nArguments\n\nSame as the schrieffer_wolff(H::QuExpr, ...) method.\n\nReturns\n\nNamed tuple (H_eff, S, H_P) where H_eff and S may be SymExpr types.\n\nExample\n\nusing QuantumAlgebra, UnitaryTransformations, Symbolics\nimport QuantumAlgebra: sumindex, SymSum, SymExpr\n\n@variables ω_c Δ g\n\ni = sumindex(1)\nH = SymExpr(ω_c * a'()*a()) + \n    SymSum(Δ/2 * σz(i), i) + \n    SymSum(g * (a'()*σm(i) + a()*σp(i)), i)\n\nP = Subspace(a'()*a() => 0)  # Zero photon sector\nresult = schrieffer_wolff(H, P; order=2)\n\nNotes\n\nCurrently only supports order=2 for SymExpr inputs\nThe effective Hamiltonian includes both same-site and cross-site terms\nFor higher orders, expand the SymSum to explicit indices first\n\n\n\n\n\nschrieffer_wolff(H::SymSum, P::Subspace; order::Int=2, ...)\n\nConvenience method: wrap a single SymSum in a SymExpr and call the main method.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.sw_generator","page":"API Reference","title":"UnitaryTransformations.sw_generator","text":"sw_generator(H::QuExpr, P::Subspace; order::Int=1)\n\nCompute only the generator S for the Schrieffer-Wolff transformation, without computing the full effective Hamiltonian.\n\nThis is useful when you only need S, or want to manually compute the transformation using bch_transform.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.magnus_expansion","page":"API Reference","title":"UnitaryTransformations.magnus_expansion","text":"magnus_expansion(H::FourierHamiltonian; order::Int=2, check_hermitian::Bool=true)\n\nCompute the Magnus expansion for a periodically driven system to arbitrary order.\n\nArguments\n\nH: A FourierHamiltonian representing H(t) = Σₙ Hₙ e^{inωt}\norder: Maximum order of the expansion (default: 2, no upper limit)\ncheck_hermitian: Whether to verify H is Hermitian (default: true)\n\nReturns\n\nA MagnusResult containing:\n\nH_eff: The effective time-independent Hamiltonian\norders: Dict mapping order k to Ωₖ\nΩ1, Ω2, ...: Direct access to individual contributions\n\nExample\n\nusing QuantumAlgebra, UnitaryTransformations, Symbolics\nQuantumAlgebra.use_σpm(true)\n\n@variables Δ Ω ω\nmodes = Dict(0 => Δ/2*σz(), 1 => Ω/2*σp(), -1 => Ω/2*σm())\nresult = magnus_expansion(modes, ω; order=5)\nprintln(\"Order 5: \", result.Ω5)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.FourierHamiltonian","page":"API Reference","title":"UnitaryTransformations.FourierHamiltonian","text":"FourierHamiltonian\n\nRepresents a time-periodic Hamiltonian in Fourier representation:     H(t) = Σₙ Hₙ e^{inωt}\n\nThe modes are stored as a Dict{Int, QuExpr} mapping Fourier index n to operator Hₙ.\n\nFor Hermiticity, we require H₋ₙ = Hₙ†.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitaryTransformations.check_hermiticity","page":"API Reference","title":"UnitaryTransformations.check_hermiticity","text":"check_hermiticity(H::FourierHamiltonian; warn_only::Bool=false)\n\nCheck that the Fourier Hamiltonian satisfies H₋ₙ = Hₙ† for all modes.\n\nReturns true if Hermitian, throws an error otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.MagnusResult","page":"API Reference","title":"UnitaryTransformations.MagnusResult","text":"MagnusResult\n\nResult type for Magnus expansion containing H_eff and individual order contributions.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitaryTransformations.Subspace","page":"API Reference","title":"UnitaryTransformations.Subspace","text":"Subspace(constraints...)\n\nDefine a low-energy subspace P by specifying constraints on operators.\n\nExamples\n\n# Spin-down subspace\nP = Subspace(σz() => -1)\n\n# Vacuum subspace (zero bosons)\nP = Subspace(a'()*a() => 0)\n\n# Product state: spin-down AND zero bosons\nP = Subspace(σz() => -1, a'()*a() => 0)\n\n# Indexed systems\nP = Subspace(σz(:i) => -1)  # All spins down\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitaryTransformations.OperatorConstraint","page":"API Reference","title":"UnitaryTransformations.OperatorConstraint","text":"OperatorConstraint\n\nA single constraint defining a sector: an operator and its eigenvalue in that sector.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitaryTransformations.decompose","page":"API Reference","title":"UnitaryTransformations.decompose","text":"decompose(H::QuExpr, P::Subspace)\n\nDecompose H into diagonal and off-diagonal parts with respect to subspace P.\n\nReturns (Hd, Hod) where:\n\nH_d is the block-diagonal part\nH_od is the off-block-diagonal part\nH = Hd + Hod\n\n\n\n\n\ndecompose(s::SymSum, P::Subspace)\n\nDecompose a symbolic sum into diagonal and off-diagonal parts. The decomposition is applied to the inner expression of the sum.\n\nReturns (SymSumd, SymSumod) where both are SymSum with the same index.\n\n\n\n\n\ndecompose(s::SymProd, P::Subspace)\n\nDecompose a symbolic product. Products are generally treated as off-diagonal unless explicitly simplified.\n\n\n\n\n\ndecompose(e::SymExpr, P::Subspace)\n\nDecompose a symbolic expression containing sums, products, and regular terms. Returns (SymExprd, SymExprod).\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.diagonal_part","page":"API Reference","title":"UnitaryTransformations.diagonal_part","text":"diagonal_part(H::QuExpr, P::Subspace)\n\nExtract the block-diagonal part of H with respect to subspace P. This includes terms that preserve P (P·H·P) and terms that preserve Q (Q·H·Q).\n\nNote: Terms classified as MIXED (like σx when not using σpm mode) are skipped. For proper handling, ensure Hamiltonians are expressed in the σ± basis.\n\n\n\n\n\ndiagonal_part(s::SymSum, P::Subspace)\n\nExtract the diagonal part of a symbolic sum.\n\n\n\n\n\ndiagonal_part(e::SymExpr, P::Subspace)\n\nExtract the diagonal part of a symbolic expression.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.off_diagonal_part","page":"API Reference","title":"UnitaryTransformations.off_diagonal_part","text":"off_diagonal_part(H::QuExpr, P::Subspace)\n\nExtract the off-block-diagonal part of H with respect to subspace P. This includes terms that couple P to Q (P·H·Q + Q·H·P).\n\nNote: MIXED terms (like σx in σz basis, or off-diagonal Lie algebra generators) are included in the off-diagonal part since they contain off-diagonal components that couple different subspaces.\n\n\n\n\n\noff_diagonal_part(s::SymSum, P::Subspace)\n\nExtract the off-diagonal part of a symbolic sum.\n\n\n\n\n\noff_diagonal_part(e::SymExpr, P::Subspace)\n\nExtract the off-diagonal part of a symbolic expression.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.is_diagonal","page":"API Reference","title":"UnitaryTransformations.is_diagonal","text":"is_diagonal(expr::QuExpr, P::Subspace)\n\nCheck if an expression is purely block-diagonal with respect to subspace P.\n\n\n\n\n\nis_diagonal(s::SymSum, P::Subspace)\n\nCheck if a symbolic sum is purely diagonal.\n\n\n\n\n\nis_diagonal(e::SymExpr, P::Subspace)\n\nCheck if a symbolic expression is purely diagonal.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.is_off_diagonal","page":"API Reference","title":"UnitaryTransformations.is_off_diagonal","text":"is_off_diagonal(expr::QuExpr, P::Subspace)\n\nCheck if an expression is purely off-block-diagonal with respect to subspace P.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.solve_for_generator","page":"API Reference","title":"UnitaryTransformations.solve_for_generator","text":"solve_for_generator(H_d::QuExpr, V_od::QuExpr, P::Subspace)\n\nSolve [S, Hd] = -Vod for the generator S.\n\nThis is the core equation in Schrieffer-Wolff: we need to find S such that the commutator with the diagonal part cancels the off-diagonal perturbation.\n\nThe fundamental solution in the energy eigenbasis is:     S{ij} = V{ij} / (Ei - Ej)\n\nTwo methods are automatically selected based on operator types:\n\nEigenoperator method (TLS, bosons, N-level transitions): For operators O  where [H_d, O] = ε·O, the solution is S = V/ε directly.\nMatrix-element method (SU(N) Lie algebras): Convert to the Cartan-Weyl  (transition) basis where operators ARE eigenoperators, apply S{ij} = V{ij}/(Ei - Ej), then convert back.\n\nUses Symbolics.jl for proper symbolic division, allowing denominators like (Δ - ω).\n\nArguments\n\nH_d: The diagonal (unperturbed) Hamiltonian\nV_od: The off-diagonal perturbation to be eliminated\nP: The subspace defining the block structure\n\nReturns\n\nS: The generator of the transformation\n\n\n\n\n\nsolve_for_generator(H_d::QuExpr, V_od::SymSum, P::Subspace)\n\nSolve [S, Hd] = -Vod for the generator S when V_od is a symbolic sum.\n\nFor a symbolic sum Σᵢ V(i), the generator is also a symbolic sum Σᵢ S(i) where each S(i) is computed using the eigenoperator method.\n\nKey insight\n\nFor operators with sum indices, [Hd, Σᵢ O(i)] = Σᵢ [Hd, O(i)] since H_d typically doesn't depend on the sum index. The generator is then:     S = Σᵢ V(i)/ε(i) where ε(i) is the energy denominator for each term.\n\n\n\n\n\nsolve_for_generator(H_d::QuExpr, V_od::SymExpr, P::Subspace)\n\nSolve [S, Hd] = -Vod for the generator S when V_od is a symbolic expression.\n\nFor a symbolic expression with multiple terms, solve for each term separately and combine the results.\n\n\n\n\n\nsolve_for_generator(H_d::SymExpr, V_od::QuExpr, P::Subspace)\n\nSolve when Hd is a SymExpr and Vod is a regular QuExpr. Extract the scalar (QuExpr) part of H_d for the generator equation.\n\n\n\n\n\nsolve_for_generator(H_d::SymExpr, V_od::SymSum, P::Subspace)\n\nSolve when both Hd and Vod involve symbolic sums.\n\n\n\n\n\nsolve_for_generator(H_d::SymExpr, V_od::SymExpr, P::Subspace)\n\nSolve when both Hd and Vod are symbolic expressions.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.solve_for_generator_eigenoperator","page":"API Reference","title":"UnitaryTransformations.solve_for_generator_eigenoperator","text":"solve_for_generator_eigenoperator(H_d::QuExpr, V_od::QuExpr, P::Subspace)\n\nSolve [S, Hd] = -Vod using the eigenoperator method.\n\nThis method works for operators O where [H_d, O] = ε·O (eigenoperators of the  adjoint action). The solution is simply S = V/ε.\n\nExamples of eigenoperators:\n\nσ± for TLS with H_d ∝ σz: [σz, σ±] = ±2σ±\na, a† for bosons with H_d ∝ a†a: [a†a, a] = -a, [a†a, a†] = a†\n|i⟩⟨j| for N-level with diagonal Hd: [Hd, |i⟩⟨j|] = (Ei - Ej)|i⟩⟨j|\n\nFor each term in Vod, the corresponding term in S is Vterm / ε.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.solve_for_generator_lie","page":"API Reference","title":"UnitaryTransformations.solve_for_generator_lie","text":"solve_for_generator_lie(H_d::QuExpr, V_od::QuExpr, N::Int, generators::Tuple;\n                        algebra_id=SU3_ALGEBRA_ID)\n\nSolve [S, Hd] = -Vod for the generator S by building the commutator matrix in the off-diagonal generator basis and solving a linear system.\n\nThis matches QuantumAlgebra's normal-form commutator semantics, which can differ from the ideal matrix-element method for SU(3).\n\nArguments\n\nH_d: The diagonal Hamiltonian (in diagonal generators only)\nV_od: The off-diagonal perturbation to be eliminated\nN: Dimension of the representation (2 for SU(2), 3 for SU(3))\ngenerators: Tuple of SU(N) generators (from su_generators)\nalgebra_id: The algebra identifier (default: SU3ALGEBRAID)\n\nReturns\n\nS: The generator of the transformation\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.compute_energy_denominator","page":"API Reference","title":"UnitaryTransformations.compute_energy_denominator","text":"compute_energy_denominator(H_d::QuExpr, term::QuTerm, P::Subspace)\n\nCompute the energy denominator for a given off-diagonal term.\n\nFor an off-diagonal operator O, computes ε where [Hd, O] = ε·O. This is the energy difference Ei - E_j for the transition that O represents.\n\nReturns the energy denominator as a Symbolics Num expression, or nothing if the operator commutes with H_d (degenerate case).\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.compute_energy_eigenvalues","page":"API Reference","title":"UnitaryTransformations.compute_energy_eigenvalues","text":"compute_energy_eigenvalues(H_d::QuExpr, N::Int, algebra_id::UInt16)\n\nCompute energy eigenvalues for an N-level system from a diagonal Hamiltonian expressed in terms of Lie algebra generators.\n\nFor SU(N), the diagonal generators (Cartan subalgebra) have known eigenvalues. This function extracts the coefficients from H_d and computes Eᵢ for each state.\n\nReturns a vector of symbolic expressions [E₁, E₂, ..., Eₙ].\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.detect_lie_algebra_system","page":"API Reference","title":"UnitaryTransformations.detect_lie_algebra_system","text":"detect_lie_algebra_system(V_od::QuExpr)\n\nDetect if V_od contains Lie algebra generators and return information about the algebra.\n\nReturns nothing if no Lie algebra operators found, or a NamedTuple with:\n\nN: dimension of the algebra (2 for SU(2), 3 for SU(3))\nalgebra_id: the UInt16 algebra identifier\nname: the generator name (e.g., :λ)\ninds: the indices tuple\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.project_to_subspace","page":"API Reference","title":"UnitaryTransformations.project_to_subspace","text":"project_to_subspace(H::QuExpr, P::Subspace)\n\nProject an operator onto the subspace P.\n\nThis replaces diagonal operators by their eigenvalues in P:\n\nσz → eigenvalue (e.g., -1 for spin down)\nσ⁺σ⁻ → 0 for spin down, 1 for spin up\na†a → eigenvalue (e.g., 0 for vacuum)\n\nAnd removes any remaining off-diagonal terms.\n\n\n\n\n\nproject_to_subspace(s::SymSum, P::Subspace)\n\nProject a symbolic sum onto the subspace P.\n\nThe projection is applied to the inner expression of the sum. If the inner expression projects to zero (e.g., σ⁺σ⁻ in spin-down subspace), the entire sum becomes zero.\n\nExample\n\nFor Σᵢ σ⁺(i)σ⁻(i) with P = Subspace(σz() => -1):\n\nThe inner term σ⁺σ⁻ → 0 for spin-down\nTherefore the entire sum → 0\n\n\n\n\n\nproject_to_subspace(s::SymProd, P::Subspace)\n\nProject a symbolic product onto the subspace P.\n\n\n\n\n\nproject_to_subspace(e::SymExpr, P::Subspace)\n\nProject a symbolic expression onto the subspace P.\n\nThis applies project_to_subspace to both the scalar (QuExpr) part and all symbolic aggregate terms (SymSum, SymProd).\n\nNotes\n\nCross-site terms like Σᵢ≠ⱼ σ⁺(i)σ⁻(j) are kept (they don't involve single-site projections that would set them to zero)\nSame-site terms like Σᵢ σ⁺(i)σ⁻(i) become zero if P is spin-down\n\nExample\n\nusing QuantumAlgebra, UnitaryTransformations\nimport QuantumAlgebra: sumindex, SymSum, SymExpr\n\ni = sumindex(1)\nH = SymExpr(a'()*a()) + SymSum(σz(i)/2, i)\n\nP = Subspace(a'()*a() => 0, σz() => -1)\nH_P = project_to_subspace(H, P)\n# H_P will have a†a → 0 and Σᵢ σz(i)/2 → Σᵢ(-1/2) = -N/2 (symbolic)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.bch_transform","page":"API Reference","title":"UnitaryTransformations.bch_transform","text":"bch_transform(S::QuExpr, A::QuExpr; order::Int=4)\n\nCompute e^S A e^{-S} using the BCH formula to the specified order.\n\nThis computes the adjoint action of e^S on an operator A:     e^S A e^{-S} = A + [S,A] + (1/2!)[S,[S,A]] + (1/3!)[S,[S,[S,A]]] + ...\n\nArguments\n\nS: The generator (typically anti-Hermitian: S† = -S)\nA: The operator to transform (e.g., a Hamiltonian)\norder: Number of nested commutators to include (default: 4)\n\nExample\n\nusing QuantumAlgebra, UnitaryTransformations, Symbolics\n@variables g Δ\n\n# Generator from SW transformation\nS = (g/Δ) * (a'()*σm() - a()*σp())\n\n# Transform the Hamiltonian\nH = Δ/2 * σz() + g * (a'()*σm() + a()*σp())\nH_transformed = bch_transform(S, H; order=2)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.commutator_series","page":"API Reference","title":"UnitaryTransformations.commutator_series","text":"commutator_series(S::QuExpr, H::QuExpr, order::Int)\n\nCompute the BCH expansion of e^S H e^{-S} to the given order.\n\ne^S H e^{-S} = Σₙ (1/n!) [S, [S, [..., [S, H]...]]]  (n nested commutators)\n\nThe expansion is truncated at order nested commutators.\n\nArguments\n\nS: The generator of the unitary transformation (anti-Hermitian: S† = -S)\nH: The operator to transform\norder: Maximum number of nested commutators to include\n\nReturns\n\nThe transformed operator as a QuExpr\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.nested_commutator","page":"API Reference","title":"UnitaryTransformations.nested_commutator","text":"nested_commutator(S::QuExpr, H::QuExpr, n::Int)\n\nCompute the n-fold nested commutator [S, [S, [..., [S, H]...]]] with S appearing n times.\n\nn=0 returns H\nn=1 returns [S, H]\nn=2 returns [S, [S, H]]\netc.\n\n\n\n\n\nnested_commutator(operators::Vector{QuExpr})\n\nCompute the left-nested commutator [...[[A₁, A₂], A₃], ..., Aₙ].\n\n\n\n\n\nnested_commutator(H::FourierHamiltonian, indices)\n\nCompute the nested commutator for given Fourier indices.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.simplify_coefficients","page":"API Reference","title":"UnitaryTransformations.simplify_coefficients","text":"simplify_coefficients(expr::QuExpr; mode::Symbol=:fast)\n\nSimplify all Symbolics coefficients in a QuExpr. Returns a new QuExpr with simplified coefficients.\n\nModes\n\n:none - No simplification (fastest, for internal computations)\n:fast - Basic expansion only (default, very fast)\n:standard - Use simplify(; expand=true) (slower but more thorough)\n:fractions - Use simplify_fractions (slow, simplifies rational expressions)\n:aggressive - Use full simplify (slowest, most thorough)\n\nNote: The :fractions and :aggressive modes can be extremely slow on complex  expressions due to polynomial GCD and rewriting computations. Use :fast for  most cases - it flattens expressions and combines like terms efficiently.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.substitute_values","page":"API Reference","title":"UnitaryTransformations.substitute_values","text":"substitute_values(expr::QuExpr, values::Dict{Symbol, Number})\n\nSubstitute numerical values for symbolic parameters in a QuExpr.\n\nArguments\n\nexpr: A QuExpr with symbolic coefficients\nvalues: Dict mapping parameter symbols to numerical values\n\nExample\n\nH_P = result.H_P\nvalues = Dict(:g => 0.1, :Δ => 1.0)\nH_numeric = substitute_values(H_P, values)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.extract_coefficient","page":"API Reference","title":"UnitaryTransformations.extract_coefficient","text":"extract_coefficient(expr::QuExpr, target_ops::QuExpr)\n\nExtract the coefficient of a specific operator structure from a QuExpr.\n\nArguments\n\nexpr: The full QuExpr to search\ntarget_ops: The operator structure to match (e.g., a'()*a())\n\nReturns\n\nThe coefficient (Num or Number) if found, nothing otherwise\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.collect_terms","page":"API Reference","title":"UnitaryTransformations.collect_terms","text":"collect_terms(expr::QuExpr)\n\nCollect and display all terms in a QuExpr with their simplified coefficients. Returns a vector of (operatorstring, simplifiedcoefficient) pairs.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.to_latex","page":"API Reference","title":"UnitaryTransformations.to_latex","text":"to_latex(expr::QuExpr; simplify_coeff::Bool=true)\n\nConvert a QuExpr to a LaTeX string with simplified coefficients.\n\nArguments\n\nexpr: The quantum expression to convert\nsimplify_coeff: Whether to simplify coefficients first (default: true)\n\nReturns\n\nA LaTeX string representation of the expression.\n\nExample\n\nH = Δ/2 * σz() + g * (a'() * σm() + a() * σp())\nprintln(to_latex(H))\n\n\n\n\n\nto_latex(result::NamedTuple; simplify_coeff::Bool=true)\n\nConvert a Schrieffer-Wolff result to LaTeX strings.\n\nReturns\n\nA NamedTuple with LaTeX strings for each component:\n\nH_eff: The effective Hamiltonian\nS: The generator\nH_P: The projected Hamiltonian\n\nExample\n\nresult = schrieffer_wolff(H, P; order=2)\nlatex_result = to_latex(result)\nprintln(latex_result.H_P)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.print_latex","page":"API Reference","title":"UnitaryTransformations.print_latex","text":"print_latex(expr::QuExpr; name::String=\"\", display::Bool=true, simplify_coeff::Bool=true)\n\nPrint a QuExpr as LaTeX, optionally wrapped in display math environment.\n\nArguments\n\nexpr: The quantum expression to print\nname: Optional name to show (e.g., \"H_{eff}\")\ndisplay: If true, wrap in \\[ ... \\] for display math\nsimplify_coeff: Whether to simplify coefficients first\n\nExample\n\nprint_latex(result.H_P; name=\"H_P\")\n# Output: H_P = - \\frac{1}{2} \\Delta + ...\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.show_result","page":"API Reference","title":"UnitaryTransformations.show_result","text":"show_result(result::NamedTuple; display::Bool=false, simplify_coeff::Bool=true)\n\nPretty-print all components of a Schrieffer-Wolff result in LaTeX.\n\nArguments\n\nresult: The result from schrieffer_wolff\ndisplay: If true, wrap each in display math environment\nsimplify_coeff: Whether to simplify coefficients\n\nExample\n\nresult = schrieffer_wolff(H, P; order=2)\nshow_result(result)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.param_to_symbolic","page":"API Reference","title":"UnitaryTransformations.param_to_symbolic","text":"param_to_symbolic(p::Param)\n\nConvert a QuantumAlgebra Param to a Symbolics variable. Caches variables to ensure the same param always maps to the same variable.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.symbolic_coefficient","page":"API Reference","title":"UnitaryTransformations.symbolic_coefficient","text":"symbolic_coefficient(term::QuTerm, coeff::Number)\n\nConvert a QuTerm's coefficient (Number + Params) to a single Symbolics expression. Handles both real and complex coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.clear_param_cache!","page":"API Reference","title":"UnitaryTransformations.clear_param_cache!","text":"clear_param_cache!()\n\nClear the parameter to Symbolics variable cache. Useful when starting a new calculation with fresh variables.\n\n\n\n\n\n","category":"function"},{"location":"magnus/#magnus_expansion","page":"Magnus Expansion","title":"Magnus Expansion","text":"The Magnus expansion is a technique for solving time-dependent Schrödinger equations and computing effective Hamiltonians for periodically driven (Floquet) systems.\n\n","category":"section"},{"location":"magnus/#Theory","page":"Magnus Expansion","title":"Theory","text":"","category":"section"},{"location":"magnus/#The-Problem","page":"Magnus Expansion","title":"The Problem","text":"Consider a time-dependent Schrödinger equation:\n\nifracpartial Upartial t = H(t) U(t)\n\nwhere H(t) is periodic with period T = 2piomega. We want to find an effective time-independent Hamiltonian H_texteff such that after one period:\n\nU(T) = e^-i H_texteff T","category":"section"},{"location":"magnus/#Fourier-Representation","page":"Magnus Expansion","title":"Fourier Representation","text":"A periodic Hamiltonian can be written in Fourier form:\n\nH(t) = sum_n H_n e^inomega t\n\nwhere the Hermiticity condition requires H_-n = H_n^dagger.","category":"section"},{"location":"magnus/#The-Magnus-Series","page":"Magnus Expansion","title":"The Magnus Series","text":"The solution to the Schrödinger equation can be written as:\n\nU(t) = e^Omega(t)\n\nwhere Omega(t) is the Magnus series:\n\nOmega(t) = Omega_1(t) + Omega_2(t) + Omega_3(t) + cdots\n\nThe effective Hamiltonian is:\n\nH_texteff = iOmega(T)T = sum_k=1^infty Omega_k","category":"section"},{"location":"magnus/#Orders-of-the-Expansion","page":"Magnus Expansion","title":"Orders of the Expansion","text":"First order (k=1):\n\nOmega_1 = H_0\n\nThe leading term is simply the time-averaged Hamiltonian.\n\nSecond order (k=2):\n\nOmega_2 = sum_n0 frac-H_n H_-nnomega\n\nThis captures effects like the Bloch-Siegert shift from counter-rotating drive terms.\n\nHigher orders (k≥3):\n\nFor order k, the Magnus term involves nested commutators with k Fourier components:\n\nOmega_k = sum_substackn_1ldotsn_k  sum_j n_j = 0 C(n_1ldotsn_k)  cdotsH_n_1 H_n_2 H_n_3ldots H_n_k\n\nThe coefficients are:\n\nC(n_1ldotsn_k) = frac1omega^k-1 prod_j=1^k-1 s_j\n\nwhere s_j = n_1 + cdots + n_j are partial sums.","category":"section"},{"location":"magnus/#Resonance-Condition","page":"Magnus Expansion","title":"Resonance Condition","text":"The sum sum_j n_j = 0 is the resonance condition. It ensures that only certain combinations of Fourier modes contribute to the effective Hamiltonian.","category":"section"},{"location":"magnus/#Reducible-Terms","page":"Magnus Expansion","title":"Reducible Terms","text":"A term is reducible if any intermediate partial sum s_j = 0. Such terms are excluded because they factorize into products of lower-order terms.","category":"section"},{"location":"magnus/#Convergence","page":"Magnus Expansion","title":"Convergence","text":"The Magnus expansion converges when:\n\nint_0^T H(t)  dt  pi\n\nFor high-frequency driving (omega gg H), convergence is typically rapid.","category":"section"},{"location":"magnus/#Physical-Applications","page":"Magnus Expansion","title":"Physical Applications","text":"Application Key Effect\nNMR Rotating-wave corrections\nTrapped ions Micromotion effects\nCircuit QED AC Stark shifts\nFloquet engineering Artificial gauge fields","category":"section"},{"location":"magnus/#Comparison-with-Floquet-Theory","page":"Magnus Expansion","title":"Comparison with Floquet Theory","text":"The Magnus expansion provides a high-frequency expansion of Floquet theory. While exact Floquet diagonalization gives the full quasienergy spectrum, the Magnus expansion produces analytical expressions valid in the omega gg V regime.\n\n","category":"section"},{"location":"magnus/#How-To-Guide","page":"Magnus Expansion","title":"How-To Guide","text":"This section walks through using the Magnus expansion step by step.","category":"section"},{"location":"magnus/#Step-1:-Define-Fourier-Modes","page":"Magnus Expansion","title":"Step 1: Define Fourier Modes","text":"The Magnus expansion works with Hamiltonians in Fourier representation:\n\nH(t) = sum_n H_n e^inomega t\n\nProvide the Fourier modes as a dictionary mapping mode index to operator:\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\nQuantumAlgebra.use_σpm(true)\n\n@variables Δ Ω ω\n\n# H(t) = (Δ/2)σz + (Ω/2)(e^{iωt}σ⁺ + e^{-iωt}σ⁻)\nmodes = Dict(\n    0  => Δ/2 * σz(),      # Time-independent part\n    1  => Ω/2 * σp(),      # e^{iωt} coefficient\n    -1 => Ω/2 * σm()       # e^{-iωt} coefficient\n)","category":"section"},{"location":"magnus/#Step-2:-Compute-the-Expansion","page":"Magnus Expansion","title":"Step 2: Compute the Expansion","text":"Call magnus_expansion with the Fourier modes and driving frequency:\n\nresult = magnus_expansion(modes, ω; order=4)\n\nThis returns a named tuple with:\n\nresult.H_eff - The total effective Hamiltonian\nresult.Ω1, result.Ω2, ... - Individual order contributions\nresult.orders - Dictionary of all computed orders","category":"section"},{"location":"magnus/#Step-3:-Analyze-Results","page":"Magnus Expansion","title":"Step 3: Analyze Results","text":"println(\"H_eff = \", result.H_eff)\nprintln(\"Ω₁ (time-averaged) = \", result.Ω1)\nprintln(\"Ω₂ (Bloch-Siegert) = \", result.Ω2)\nprintln(\"Ω₃ = \", result.Ω3)","category":"section"},{"location":"magnus/#Hermiticity-Check","page":"Magnus Expansion","title":"Hermiticity Check","text":"The Magnus expansion verifies that your Hamiltonian is Hermitian:\n\n# This will check H₋ₙ = Hₙ† automatically\nresult = magnus_expansion(modes, ω; check_hermitian=true)\n\n# Skip the check if you know what you're doing\nresult = magnus_expansion(modes, ω; check_hermitian=false)\n\n","category":"section"},{"location":"magnus/#Examples","page":"Magnus Expansion","title":"Examples","text":"","category":"section"},{"location":"magnus/#Circularly-Driven-Two-Level-System","page":"Magnus Expansion","title":"Circularly Driven Two-Level System","text":"A qubit driven by a circularly polarized field:\n\nH(t) = fracDelta2sigma_z + fracOmega2left(e^iomega tsigma^+ + e^-iomega tsigma^-right)\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\nQuantumAlgebra.use_σpm(true)\n\n@variables Δ Ω ω\n\n# Fourier modes: H(t) = Σₙ Hₙ exp(inωt)\nmodes = Dict(\n    0  => Δ/2 * σz(),\n    1  => Ω/2 * σp(),\n    -1 => Ω/2 * σm()\n)\n\n# Compute Magnus expansion to 4th order\nresult = magnus_expansion(modes, ω; order=4)\n\nprintln(\"H_eff = \", result.H_eff)\nprintln(\"Ω₂ (Bloch-Siegert) = \", result.Ω2)\nprintln(\"Ω₃ = \", result.Ω3)\n\nOutput (order 2):\n\nOmega_2 = -fracOmega^24omegasigma_z\n\nThis is the Bloch-Siegert shift — a correction to the qubit frequency due to counter-rotating drive terms.","category":"section"},{"location":"magnus/#Higher-Order-Corrections","page":"Magnus Expansion","title":"Higher-Order Corrections","text":"The Magnus expansion can be computed to arbitrary order:\n\n# High-order expansion\nresult = magnus_expansion(modes, ω; order=6)\n\n# Access individual orders\nprintln(\"Order 3: \", result.Ω3)  # ~ -ΔΩ²/(4ω²)\nprintln(\"Order 4: \", result.Ω4)  # ~ +Δ²Ω²/(4ω³)\nprintln(\"Order 5: \", result.Ω5)  # ~ -Δ³Ω²/(4ω⁴)\n\nPattern: For k ≥ 2, each order contributes:\n\nOmega_k = (-1)^k-1 fracDelta^k-2 Omega^24omega^k-1 sigma_z\n\nThis geometric series sums to the exact Bloch-Siegert result:\n\nH_texteff = fracDelta2left(1 - fracOmega^22omega(omega + Delta)right)sigma_z","category":"section"},{"location":"magnus/#Multiple-Driving-Frequencies","page":"Magnus Expansion","title":"Multiple Driving Frequencies","text":"For Hamiltonians with multiple Fourier components:\n\n@variables Δ Ω₁ Ω₂ ω\n\n# Bichromatic driving\nmodes = Dict(\n    0  => Δ/2 * σz(),\n    1  => Ω₁/2 * σp(),\n    -1 => Ω₁/2 * σm(),\n    2  => Ω₂/2 * σp(),\n    -2 => Ω₂/2 * σm()\n)\n\nresult = magnus_expansion(modes, ω; order=3)","category":"section"},{"location":"magnus/#Example:-AC-Stark-Shift","page":"Magnus Expansion","title":"Example: AC Stark Shift","text":"When a qubit is driven off-resonantly, the Magnus expansion captures the AC Stark shift:\n\n@variables δ Ω ω  # δ = detuning from qubit frequency\n\nmodes = Dict(\n    0  => δ/2 * σz(),\n    1  => Ω/2 * σp(),\n    -1 => Ω/2 * σm()\n)\n\nresult = magnus_expansion(modes, ω; order=2)\n\n# The AC Stark shift appears in Ω₂\nprintln(\"AC Stark shift: \", result.Ω2)\n\n","category":"section"},{"location":"magnus/#Running-the-Examples","page":"Magnus Expansion","title":"Running the Examples","text":"Complete example files are in the examples/ directory:\n\njulia --project examples/driven_qubit.jl  # Magnus expansion\n\n","category":"section"},{"location":"magnus/#Key-Points","page":"Magnus Expansion","title":"Key Points","text":"Provide Fourier modes as a Dict{Int, Operator} mapping n to H_n\nHermiticity requires H_-n = H_n^dagger — the package checks this by default\nAccess individual orders via result.Ω2, result.Ω3, etc.\nHigh-frequency limit: The expansion is most accurate when omega gg H\nUse order parameter to control the number of terms computed\n\n","category":"section"},{"location":"magnus/#References","page":"Magnus Expansion","title":"References","text":"W. Magnus, \"On the exponential solution of differential equations for a linear operator,\" Comm. Pure Appl. Math. 7, 649 (1954).\nS. Blanes et al., \"The Magnus expansion and some of its applications,\" Physics Reports 470, 151 (2009).\nA. Eckardt and E. Anisimovas, \"High-frequency approximation for periodically driven quantum systems from a Floquet-space perspective,\" New J. Phys. 17, 093039 (2015).\nM. Bukov, L. D'Alessio, and A. Polkovnikov, \"Universal high-frequency behavior of periodically driven systems: from dynamical stabilization to Floquet engineering,\" Adv. Phys. 64, 139 (2015).","category":"section"},{"location":"schrieffer_wolff/#schrieffer_wolff","page":"Schrieffer-Wolff","title":"Schrieffer-Wolff Transformation","text":"The Schrieffer-Wolff (SW) transformation is a perturbative method for block-diagonalizing Hamiltonians with well-separated energy scales. It was introduced by Schrieffer and Wolff in 1966 to derive the Kondo exchange interaction from the Anderson impurity model.\n\n","category":"section"},{"location":"schrieffer_wolff/#Theory","page":"Schrieffer-Wolff","title":"Theory","text":"","category":"section"},{"location":"schrieffer_wolff/#The-Problem","page":"Schrieffer-Wolff","title":"The Problem","text":"Consider a Hamiltonian of the form:\n\nH = H_0 + V\n\nwhere:\n\nH_0 is the unperturbed Hamiltonian with known eigenstates grouped into low-energy (P) and high-energy (Q) sectors\nV is a perturbation that couples the P and Q sectors\n\nWe want to find an effective Hamiltonian H_texteff that:\n\nActs only within the low-energy sector P\nCaptures the effects of V to a given order in perturbation theory","category":"section"},{"location":"schrieffer_wolff/#The-Transformation","page":"Schrieffer-Wolff","title":"The Transformation","text":"We seek a unitary U = e^S such that the transformed Hamiltonian:\n\nH_texteff = e^S H e^-S\n\nis block-diagonal with respect to the P and Q subspaces. This means H_texteff has no matrix elements connecting P and Q.\n\nWhen U = e^S for some anti-Hermitian generator S (i.e., S^dagger = -S), the transformed Hamiltonian can be expanded using the Baker-Campbell-Hausdorff (BCH) formula:\n\ne^S H e^-S = H + S H + frac12S S H + frac13S S S H + cdots","category":"section"},{"location":"schrieffer_wolff/#Determining-the-Generator","page":"Schrieffer-Wolff","title":"Determining the Generator","text":"Decompose the Hamiltonian and generator into block-diagonal and off-block-diagonal parts:\n\nH = H_d + V_od quad S = S_od\n\nwhere:\n\nH_d = P H P + Q H Q (block-diagonal)\nV_od = P H Q + Q H P (off-block-diagonal)\nS_od is purely off-block-diagonal (anti-Hermitian)\n\nThe generator equation at first order is:\n\nS H_d = -V_od\n\nThis is the fundamental equation that determines S. It states that the commutator of S with the diagonal Hamiltonian must cancel the off-diagonal perturbation.","category":"section"},{"location":"schrieffer_wolff/#Solving-the-Generator-Equation","page":"Schrieffer-Wolff","title":"Solving the Generator Equation","text":"For operators O that are eigenoperators of the adjoint action of H_d—meaning H_d O = varepsilon cdot O for some energy varepsilon—the solution is:\n\nS = sum_alpha fracV_alphavarepsilon_alpha\n\nwhere V_alpha are the components of V_od and varepsilon_alpha are the corresponding energy denominators.\n\nExample: For a two-level system with H_d = fracDelta2sigma_z and V_od = gsigma^+:\n\nsigma_z sigma^+ = 2sigma^+, so H_d sigma^+ = Deltasigma^+\nTherefore S = fracgDeltasigma^+ (plus Hermitian conjugate for the sigma^- term)","category":"section"},{"location":"schrieffer_wolff/#The-Effective-Hamiltonian","page":"Schrieffer-Wolff","title":"The Effective Hamiltonian","text":"Using the BCH expansion:\n\nH_texteff = H_d + frac12S V_od + O(V^3)\n\nThe key second-order contribution is:\n\nH^(2) = frac12S V_od\n\nThis generates effective interactions within the low-energy sector that arise from virtual transitions to high-energy states.","category":"section"},{"location":"schrieffer_wolff/#Physical-Interpretation","page":"Schrieffer-Wolff","title":"Physical Interpretation","text":"The SW transformation captures the physics of virtual processes:\n\nThe system starts in the low-energy sector P\nThe perturbation V virtually excites it to high-energy sector Q\nThe system returns to P via another application of V\n\nThis virtual excitation costs energy Delta E and contributes to the effective Hamiltonian as sim V^2Delta E.","category":"section"},{"location":"schrieffer_wolff/#Order-by-Order-Expansion","page":"Schrieffer-Wolff","title":"Order-by-Order Expansion","text":"At higher orders, the SW transformation proceeds iteratively:\n\nOrder Contribution Energy dependence\n0 H_d Original diagonal\n2 frac12S_1 V sim g^2Delta\n3 frac12S_1 S_1 H_d + S_2 V sim g^3Delta^2\n4 Higher nested commutators sim g^4Delta^3\n\nEach order adds terms suppressed by additional powers of gDelta.","category":"section"},{"location":"schrieffer_wolff/#Eigenoperator-Method","page":"Schrieffer-Wolff","title":"Eigenoperator Method","text":"This package implements two methods for solving the generator equation. The eigenoperator method works for operators that satisfy:\n\nH_d O = varepsilon cdot O\n\nSuch operators are called eigenoperators of the Liouvillian mathcalL_H_d(cdot) = H_d cdot.","category":"section"},{"location":"schrieffer_wolff/#Examples-of-Eigenoperators","page":"Schrieffer-Wolff","title":"Examples of Eigenoperators","text":"System Operator Eigenvalue\nTLS: H_d = fracDelta2sigma_z sigma^+ +Delta\n sigma^- -Delta\nCavity: H_d = omega a^dagger a a^dagger +omega\n a -omega\nN-level: H_d = sum_i E_i vert iranglelangle ivert vert iranglelangle jvert E_i - E_j\n\nFor these operators, the generator is simply:\n\nS = fracOvarepsilon","category":"section"},{"location":"schrieffer_wolff/#Composite-Operators","page":"Schrieffer-Wolff","title":"Composite Operators","text":"Products of eigenoperators are also eigenoperators with additive eigenvalues:\n\nH_d O_1 O_2 = (varepsilon_1 + varepsilon_2) O_1 O_2\n\nExample: For the Jaynes-Cummings interaction a^dagger sigma^-:\n\nH_d a^dagger sigma^- = (omega_c - Delta) a^dagger sigma^-\nEnergy denominator: omega_c - Delta (the detuning)","category":"section"},{"location":"schrieffer_wolff/#Matrix-Element-Method-for-Lie-Algebras","page":"Schrieffer-Wolff","title":"Matrix-Element Method for Lie Algebras","text":"For SU(N) systems expressed in the Gell-Mann basis, the generators are not eigenoperators of the diagonal Hamiltonian. For example:\n\nlambda_8 lambda_2 neq c cdot lambda_2\n\nInstead, the commutator produces a linear combination of generators.\n\nThe solution is to work in the Cartan-Weyl basis, where the off-diagonal generators are replaced by transition operators:\n\nGell-Mann Cartan-Weyl\nlambda_1 lambda_4 E_12 = vert 1ranglelangle 2vert, E_21 = vert 2ranglelangle 1vert\nlambda_2 lambda_5 E_13 = vert 1ranglelangle 3vert, E_31 = vert 3ranglelangle 1vert\nlambda_3 lambda_6 E_23 = vert 2ranglelangle 3vert, E_32 = vert 3ranglelangle 2vert\n\nThe transition operators are eigenoperators:\n\nH_d vert iranglelangle jvert = (E_i - E_j)vert iranglelangle jvert\n\nAlgorithm:\n\nCompute energy eigenvalues E_i from the diagonal Hamiltonian\nConvert V_od from Gell-Mann to Cartan-Weyl basis\nApply inverse Liouvillian: S_ij = V_ij  (E_i - E_j)\nConvert S back to Gell-Mann basis\n\nThis is implemented in solve_for_generator_lie().","category":"section"},{"location":"schrieffer_wolff/#Energy-Denominators","page":"Schrieffer-Wolff","title":"Energy Denominators","text":"The energy denominators in SW transformations have important physical meaning:","category":"section"},{"location":"schrieffer_wolff/#Resonance-Condition","page":"Schrieffer-Wolff","title":"Resonance Condition","text":"When an energy denominator approaches zero (varepsilon to 0), the perturbation theory breaks down. This indicates a resonance where the two sectors are no longer well-separated.","category":"section"},{"location":"schrieffer_wolff/#Example:-Dispersive-Regime","page":"Schrieffer-Wolff","title":"Example: Dispersive Regime","text":"In circuit QED, the Jaynes-Cummings Hamiltonian has energy denominator Delta = omega_q - omega_c. The dispersive approximation is valid when:\n\ng ll Delta\n\nThe effective Hamiltonian contains the dispersive shift:\n\nchi = -fracg^2Delta\n\nThis diverges as Delta to 0 (resonance), signaling the breakdown of the perturbative treatment.\n\n","category":"section"},{"location":"schrieffer_wolff/#How-To-Guide","page":"Schrieffer-Wolff","title":"How-To Guide","text":"This section walks through using the Schrieffer-Wolff transformation step by step.","category":"section"},{"location":"schrieffer_wolff/#Step-1:-Set-Up-the-System","page":"Schrieffer-Wolff","title":"Step 1: Set Up the System","text":"Let's work with a concrete example: a two-level system (qubit) coupled to a harmonic oscillator (the Jaynes-Cummings model).\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# Use σ± basis - important for SW to work correctly with spins\nQuantumAlgebra.use_σpm(true)\n\n# Define symbolic parameters\n@variables Δ g  # Δ = qubit-oscillator detuning, g = coupling strength\n\n# Jaynes-Cummings Hamiltonian (in rotating frame)\nH = Δ/2 * σz() + g * (a'()*σm() + a()*σp())\n\nThe Hamiltonian describes:\n\nA qubit with splitting Delta (the sigma_z term)\nCoupling to an oscillator mode (the a^dagger sigma^- and a sigma^+ terms)","category":"section"},{"location":"schrieffer_wolff/#Step-2:-Define-the-Subspace","page":"Schrieffer-Wolff","title":"Step 2: Define the Subspace","text":"We need to specify which states belong to the low-energy subspace P. For this example, we choose the qubit ground state:\n\n# P = states where σz = -1 (qubit in ground state |g⟩)\nP = Subspace(σz() => -1)\n\nThe Subspace type specifies expectation values of operators in the subspace. Here, we say that in subspace P, the operator sigma_z has eigenvalue -1.","category":"section"},{"location":"schrieffer_wolff/#Multiple-Constraints","page":"Schrieffer-Wolff","title":"Multiple Constraints","text":"For more complex systems, you can specify multiple constraints:\n\n# Subspace with qubit ground state AND zero photons\nP = Subspace(σz() => -1, a'()*a() => 0)","category":"section"},{"location":"schrieffer_wolff/#Step-3:-Understand-the-Decomposition","page":"Schrieffer-Wolff","title":"Step 3: Understand the Decomposition","text":"The SW transformation requires splitting H into diagonal and off-diagonal parts with respect to P:\n\nH_d, V_od = decompose(H, P)\n\nprintln(\"Diagonal:     \", H_d)\nprintln(\"Off-diagonal: \", V_od)\n\nOutput:\n\nDiagonal:     -0.5Δ + Δ σ⁺σ⁻\nOff-diagonal: g a†σ⁻ + g a σ⁺\n\nDiagonal (H_d): Operators that don't change the subspace (like sigma^+sigma^-, a^dagger a)\nOff-diagonal (V_od): Operators that connect P and Q subspaces (like sigma^+, sigma^-)","category":"section"},{"location":"schrieffer_wolff/#Step-4:-Perform-the-Transformation","page":"Schrieffer-Wolff","title":"Step 4: Perform the Transformation","text":"Now apply the Schrieffer-Wolff transformation:\n\nresult = schrieffer_wolff(H, P; order=2)\n\nThis returns a named tuple with:\n\nresult.S - The generator of the unitary transformation e^S\nresult.H_eff - The block-diagonal effective Hamiltonian\nresult.H_P - The effective Hamiltonian projected onto subspace P","category":"section"},{"location":"schrieffer_wolff/#Higher-Orders","page":"Schrieffer-Wolff","title":"Higher Orders","text":"You can go to higher orders for more accuracy:\n\nresult_4th = schrieffer_wolff(H, P; order=4)\n\nFor orders 4 and above, enable parallel computation for better performance:\n\n# Start Julia with threads: julia -t 4\nresult_4th = schrieffer_wolff(H, P; order=4, parallel=true)\n\nOrder Approx. Time Physics Captured\n2 ~50 ms Dispersive shifts\n4 ~0.4 s Kerr nonlinearity, Bloch-Siegert\n5 ~1.5 s Higher-order corrections\n6 ~50 s Research applications\n\nSimplification modes: Control the speed/simplification trade-off:\n\n# Fastest: no simplification (expressions may be verbose)\nresult = schrieffer_wolff(H, P; order=4, simplify_mode=:none)\n\n# Default: fast expansion (recommended)\nresult = schrieffer_wolff(H, P; order=4, simplify_mode=:fast)\n\n# Thorough: full algebraic simplification (slower)\nresult = schrieffer_wolff(H, P; order=4, simplify_mode=:standard)","category":"section"},{"location":"schrieffer_wolff/#Step-5:-Analyze-the-Results","page":"Schrieffer-Wolff","title":"Step 5: Analyze the Results","text":"","category":"section"},{"location":"schrieffer_wolff/#The-Generator","page":"Schrieffer-Wolff","title":"The Generator","text":"println(\"Generator S = \", result.S)\n# S = (g/Δ) a†σ⁻ + (-g/Δ) a σ⁺\n\nThe generator S is anti-Hermitian (S^dagger = -S) and satisfies:\n\nS H_d = -V_od","category":"section"},{"location":"schrieffer_wolff/#The-Effective-Hamiltonian-2","page":"Schrieffer-Wolff","title":"The Effective Hamiltonian","text":"# Collect and display all terms with simplified coefficients\nterms = collect_terms(result.H_eff)\nfor (op, coeff) in terms\n    println(\"  \", coeff, \"  \", op)\nend\n\nOutput:\n\n  -0.5Δ        𝟙\n  -(g²)/Δ      a†a\n  Δ + (g²)/Δ   σ⁺σ⁻\n  ...","category":"section"},{"location":"schrieffer_wolff/#The-Projected-Hamiltonian","page":"Schrieffer-Wolff","title":"The Projected Hamiltonian","text":"For many applications, we only care about the subspace P:\n\nprintln(\"H_P = \", result.H_P)\n# H_P = -0.5Δ + (-(g²)/Δ) a†a\n\nThis is the dispersive Hamiltonian: the cavity frequency is shifted by -g^2Delta when the qubit is in the ground state!","category":"section"},{"location":"schrieffer_wolff/#Step-6:-Extract-Physical-Parameters","page":"Schrieffer-Wolff","title":"Step 6: Extract Physical Parameters","text":"Use utility functions to extract specific coefficients:\n\n# Get the dispersive shift (coefficient of a†a)\nχ = extract_coefficient(result.H_P, a'()*a())\nprintln(\"Dispersive shift χ = \", χ)\n# Output: -(g²)/Δ","category":"section"},{"location":"schrieffer_wolff/#Step-7:-Numerical-Evaluation","page":"Schrieffer-Wolff","title":"Step 7: Numerical Evaluation","text":"Substitute numerical values to get concrete numbers:\n\nH_numeric = substitute_values(result.H_P, Dict(:g => 0.1, :Δ => 1.0))\nprintln(\"H_P with g=0.1, Δ=1.0: \", H_numeric)","category":"section"},{"location":"schrieffer_wolff/#Step-8:-LaTeX-Output","page":"Schrieffer-Wolff","title":"Step 8: LaTeX Output","text":"For publications and documentation, you can output results in LaTeX:\n\n# Convert a single expression to LaTeX\nprintln(to_latex(result.H_P))\n# Output: - \\frac{1}{2} \\Delta + \\frac{-g^{2}}{\\Delta} {a}^{\\dagger} {a}\n\n# Pretty-print with a name\nprint_latex(result.H_P; name=\"H_P\")\n# Output: H_P = - \\frac{1}{2} \\Delta + \\frac{-g^{2}}{\\Delta} {a}^{\\dagger} {a}\n\n# Show all components of the result\nshow_result(result)","category":"section"},{"location":"schrieffer_wolff/#Complete-Example","page":"Schrieffer-Wolff","title":"Complete Example","text":"Here's the full code:\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# Setup\nQuantumAlgebra.use_σpm(true)\n\n# Define symbolic parameters and Hamiltonian\n@variables Δ g\nH = Δ/2 * σz() + g * (a'()*σm() + a()*σp())\n\n# Define subspace and transform\nP = Subspace(σz() => -1)\nresult = schrieffer_wolff(H, P; order=2)\n\n# Analyze results\nprintln(\"Effective Hamiltonian in ground state subspace:\")\nfor (op, coeff) in collect_terms(result.H_P)\n    println(\"  \", coeff, \"  \", op)\nend\n\n# Extract dispersive shift\nχ = extract_coefficient(result.H_P, a'()*a())\nprintln(\"\\nDispersive shift: χ = \", χ)\nprintln(\"Expected: -g²/Δ\")\n\n","category":"section"},{"location":"schrieffer_wolff/#Examples","page":"Schrieffer-Wolff","title":"Examples","text":"","category":"section"},{"location":"schrieffer_wolff/#Convergence-Analysis","page":"Schrieffer-Wolff","title":"Convergence Analysis","text":"The following figure demonstrates how higher-order SW transformations systematically improve the accuracy of the effective Hamiltonian:\n\n(Image: Summary of SW transformations at different orders)\n\nKey observations:\n\nPanel (a): Energy levels of a two-level system. Higher orders capture the curvature better.\nPanel (b): The energy gap E_+ - E_- approaches the exact sqrtDelta^2 + 4varepsilon^2 with higher orders.\nPanel (c): Relative error decreases with increasing SW order.\nPanel (d): Jaynes-Cummings model showing dispersive shift chi and Kerr nonlinearity K (only present at order 4+).","category":"section"},{"location":"schrieffer_wolff/#Jaynes-Cummings:-Dispersive-Regime","page":"Schrieffer-Wolff","title":"Jaynes-Cummings: Dispersive Regime","text":"The Jaynes-Cummings model describes a two-level atom coupled to a single cavity mode:\n\nH = omega_c a^dagger a + fracomega_q2sigma_z + g(a^daggersigma^- + asigma^+)\n\nIn the dispersive regime (Delta = omega_q - omega_c gg g), the Schrieffer-Wolff transformation yields an effective Hamiltonian with a state-dependent frequency shift.\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\nQuantumAlgebra.use_σpm(true)\n\n@variables Δ g  # Δ = detuning, g = coupling\n\n# Hamiltonian (in rotating frame)\nH = Δ/2 * σz() + g * (a'()*σm() + a()*σp())\n\n# Ground state subspace\nP = Subspace(σz() => -1)\n\n# Transform and display results\nresult = schrieffer_wolff(H, P; order=2)\nshow_result(result)\n\nGenerator:\n\nS = frac-g2Delta a^dagger sigma^- + fracg2Delta sigma^+ a\n\nEffective Hamiltonian:\n\nH_texteff = -fracDelta2 - fracg^2Delta a^dagger a + fracg^2 + Delta^2Delta sigma^+ sigma^- + frac2g^2Delta a^dagger sigma^+ sigma^- a\n\nProjected to subspace P (qubit ground state):\n\nH_P = -fracDelta2 - fracg^2Delta a^dagger a","category":"section"},{"location":"schrieffer_wolff/#Physical-Interpretation-2","page":"Schrieffer-Wolff","title":"Physical Interpretation","text":"The effective Hamiltonian contains:\n\nDispersive shift: chi = -g^2Delta — cavity frequency shifts when qubit is in ground state\nAC Stark shift: Qubit frequency shifts with photon number\n\nThis is the basis for qubit readout in circuit QED!\n\n(Image: Jaynes-Cummings dispersive shift and Kerr nonlinearity)","category":"section"},{"location":"schrieffer_wolff/#Extracting-Parameters","page":"Schrieffer-Wolff","title":"Extracting Parameters","text":"χ = extract_coefficient(result.H_P, a'()*a())\nprintln(to_latex(χ))  # Output: \\frac{-g^{2}}{\\Delta}\n\n# Numerical evaluation\nH_num = substitute_values(result.H_P, Dict(:g => 0.1, :Δ => 1.0))\n# χ = -0.01, matching -g²/Δ","category":"section"},{"location":"schrieffer_wolff/#Tavis-Cummings:-N-Atoms-in-a-Cavity","page":"Schrieffer-Wolff","title":"Tavis-Cummings: N Atoms in a Cavity","text":"The Tavis-Cummings model generalizes Jaynes-Cummings to N identical two-level atoms coupled to a single cavity mode:\n\nH = omega_c a^dagger a + sum_i fracDelta_i2sigma_z^(i) + sum_i g_i (a^daggersigma^(i)_- + asigma^(i)_+)\n\nThis model describes multi-qubit circuit QED systems and collective atom-light interactions.","category":"section"},{"location":"schrieffer_wolff/#Using-Symbolic-Sums-(Recommended-for-N-Atoms)","page":"Schrieffer-Wolff","title":"Using Symbolic Sums (Recommended for N Atoms)","text":"For systems with an arbitrary number of atoms, use SymSum and SymExpr to represent the Hamiltonian symbolically:\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\nimport QuantumAlgebra: sumindex, SymSum, SymExpr\n\nQuantumAlgebra.use_σpm(true)\n\n@variables ω_c Δ g  # cavity freq, detuning, coupling\n\n# Create a sum index representing Σᵢ over all atoms\ni = sumindex(1)\n\n# Build Tavis-Cummings Hamiltonian with symbolic sums\nH = SymExpr(ω_c * a'()*a()) + \n    SymSum(Δ/2 * σz(i), i) + \n    SymSum(g * (a'()*σm(i) + a()*σp(i)), i)\n\n# Zero-photon subspace (dispersive regime)\nP = Subspace(a'()*a() => 0)\n\nresult = schrieffer_wolff(H, P; order=2)\n\nKey advantage: When computing commutators like sum_i S_i sum_j V_j, the SymSum type correctly separates:\n\nSame-site terms (i = j): sum_i S_i V_i  \nCross-site terms (i neq j): sum_i sum_j neq i S_i V_j\n\nThis produces the physically correct exchange interactions automatically!\n\nGenerator:\n\nS = sum_i fracgDelta - omega_c a^dagger sigma^(i)_- + frac-gDelta - omega_c sigma^(i)_+ a\n\nEffective Hamiltonian:\n\nH_texteff = omega_c a^dagger a + sum_ifracDelta2 sigma_z^(i) + chi  a^dagger a sum_i sigma_z^(i) + chi sum_i neq j sigma^+_i sigma^-_j + textconst\n\nwhere chi = g^2(Delta - omega_c) is the dispersive shift per atom.","category":"section"},{"location":"schrieffer_wolff/#Physical-Interpretation-3","page":"Schrieffer-Wolff","title":"Physical Interpretation","text":"The Tavis-Cummings effective Hamiltonian reveals collective effects:\n\nCollective Lamb shift: Cavity frequency shifts by -Nchi (N atoms contribute)\nAC Stark shift: Each atom's frequency shifts by 2chi per photon\nDispersive coupling: chi cdot a^dagger a cdot J_z where J_z = sum_i sigma_z^(i)2\nExchange interaction: chi sum_i neq j sigma^+_i sigma^-_j — cavity-mediated spin-spin coupling\n\nFor N atoms, the vacuum Rabi splitting scales as gsqrtN, leading to enhanced dispersive effects. This is the foundation for:\n\nMulti-qubit dispersive readout in circuit QED\nCollective spin squeezing\nQuantum non-demolition measurements of collective spin","category":"section"},{"location":"schrieffer_wolff/#Numerical-Example","page":"Schrieffer-Wolff","title":"Numerical Example","text":"For N = 10 atoms with Delta = 10 GHz, g = 01 GHz:\n\nSingle-atom dispersive shift: chi = g^2Delta = 10 MHz\nCollective Lamb shift: 10 times 10 MHz = 100 MHz\nAC Stark shift per atom: 20 MHz per photon","category":"section"},{"location":"schrieffer_wolff/#Exchange-Interaction:-The-Cross-Site-Term","page":"Schrieffer-Wolff","title":"Exchange Interaction: The Cross-Site Term","text":"The exchange term chi sum_i neq j sigma^+_i sigma^-_j arises from virtual photon exchange between atoms. For two atoms, expanding the result:\n\n# Expand to N=2 atoms to see explicit exchange terms\nusing QuantumAlgebra: expand_symsum\n\nH_eff_N2 = expand_symsum(result.H_eff, 2)  # Expand to 2 atoms\n\n# Result includes: χ(σ⁺₁σ⁻₂ + σ⁺₂σ⁻₁)\n\nThe exchange term represents cavity-mediated spin-spin coupling. For N atoms, this generalizes to:\n\nH_textexchange = chi sum_i neq j sigma^+_i sigma^-_j = chi (J_+ J_- + J_- J_+)2 - chi N\n\nwhere J_pm = sum_i sigma^pm_i are collective spin ladder operators. This is the foundation for:\n\nCavity-mediated quantum gates\nDicke superradiance\nSpin squeezing via one-axis twisting","category":"section"},{"location":"schrieffer_wolff/#Alternative:-Explicit-Indices-(for-Small-N)","page":"Schrieffer-Wolff","title":"Alternative: Explicit Indices (for Small N)","text":"For small, fixed numbers of atoms (e.g., N=2), you can use explicit site indices:\n\n# Two explicit atoms (not using sum index)\nH = ω_c * a'()*a() + \n    Δ/2 * σz(1) + Δ/2 * σz(2) + \n    g * (a'()*σm(1) + a()*σp(1)) +\n    g * (a'()*σm(2) + a()*σp(2))\n\nP = Subspace(a'()*a() => 0)\nresult = schrieffer_wolff(H, P; order=2)\n\n# Directly contains: χ(σ⁺₁σ⁻₂ + σ⁺₂σ⁻₁)\n\nThis approach is simpler for small N but doesn't scale to arbitrary N like SymSum.","category":"section"},{"location":"schrieffer_wolff/#Projecting-SymExpr-to-Subspace","page":"Schrieffer-Wolff","title":"Projecting SymExpr to Subspace","text":"The project_to_subspace function works with SymExpr, allowing you to project the effective Hamiltonian onto the low-energy subspace:\n\n# Full effective Hamiltonian (block-diagonal)\nresult = schrieffer_wolff(H, P; order=2)\nH_eff = result.H_eff  # Contains terms for both P and Q sectors\n\n# Project to subspace P (removes off-diagonal terms, substitutes spin projections)\nH_P = project_to_subspace(H_eff, P)\n\n# Or use result.H_P directly (already projected)\nH_P = result.H_P\n\nWhat project_to_subspace does for SymExpr:\n\nRemoves off-diagonal operators — terms like sigma^+, sigma^- that connect P and Q\nSubstitutes spin projections — sigma^+sigma^- becomes 0 (spin-down) or 1 (spin-up)\nPreserves symbolic sums — sum_i sigma_z^(i) remains as a symbolic sum\n\nExample:\n\n# Define subspace with both cavity and spin constraints\nP = Subspace(a'()*a() => 0, σz() => -1)\n\n# Project: σ⁺σ⁻ → 0 (for spin-down), off-diagonal terms removed\nH_P = project_to_subspace(result.H_eff, P)\n\nNote: The projection substitutes spin operators but keeps bosonic operators like a^dagger a symbolically (they are diagonal but not numerically evaluated). This allows the result to remain valid for any photon number within the subspace constraints.\n\n","category":"section"},{"location":"schrieffer_wolff/#Two-Level-System-with-Transverse-Field","page":"Schrieffer-Wolff","title":"Two-Level System with Transverse Field","text":"A qubit in longitudinal and transverse magnetic fields:\n\nH = fracDelta2sigma_z + varepsilonsigma_x\n\nThis textbook problem has an exact solution, making it perfect for verification.\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\nQuantumAlgebra.use_σpm(true)\n\n@variables Δ ε\n\nH = Δ/2 * σz() + ε * (σp() + σm())\nP = Subspace(σz() => -1)\n\nresult = schrieffer_wolff(H, P; order=2)\nprint_latex(result.H_P; name=\"H_P\")\n\nOutput:\n\nH_P = -fracDelta2 - fracvarepsilon^2Delta","category":"section"},{"location":"schrieffer_wolff/#Comparison-with-Exact-Solution","page":"Schrieffer-Wolff","title":"Comparison with Exact Solution","text":"The exact ground state energy is:\n\nE_- = -sqrtfracDelta^24 + varepsilon^2 approx -fracDelta2 - fracvarepsilon^2Delta + O(varepsilon^4)\n\nThe SW result matches the perturbation expansion exactly!\n\n(Image: Two-level system: SW orders vs exact solution)\n\nvarepsilonDelta Exact SW (2nd order) Error\n0.01 -0.50005 -0.5001 0.00%\n0.05 -0.50125 -0.5025 0.00%\n0.10 -0.50499 -0.51 0.02%\n0.20 -0.51980 -0.54 0.28%","category":"section"},{"location":"schrieffer_wolff/#Convergence-with-Order","page":"Schrieffer-Wolff","title":"Convergence with Order","text":"(Image: Convergence of SW expansion)\n\nThe figure shows how the approximation error decreases with increasing SW order. For small perturbations (varepsilonDelta  03), convergence is rapid. For larger coupling, more orders are needed.","category":"section"},{"location":"schrieffer_wolff/#Rabi-Model:-Bloch-Siegert-Shift","page":"Schrieffer-Wolff","title":"Rabi Model: Bloch-Siegert Shift","text":"The full Rabi model includes counter-rotating terms neglected in the rotating-wave approximation:\n\nH = omega a^dagger a + fracDelta2sigma_z + g(sigma^+ + sigma^-)(a + a^dagger)\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\nQuantumAlgebra.use_σpm(true)\n\n@variables ω Δ g\n\nH = ω * a'()*a() + Δ/2 * σz() + g * (σp() + σm()) * (a() + a'())\nP = Subspace(σz() => -1)\n\nresult = schrieffer_wolff(H, P; order=2)\nprint_latex(result.H_P; name=\"H_P\")\n\nOutput:\n\nH_P = -fracDelta2 + omega a^dagger a - fracg^2Delta - omega a^dagger a - fracg^2Delta + omega a^dagger a + fracg^2Delta + omega - fracg^2Delta + omega (a^dagger)^2 - fracg^2Delta + omega a^2","category":"section"},{"location":"schrieffer_wolff/#Physical-Interpretation-4","page":"Schrieffer-Wolff","title":"Physical Interpretation","text":"Compared to Jaynes-Cummings, the full Rabi model produces:\n\nJC dispersive shift: -g^2(Delta - omega) from rotating terms\nBloch-Siegert shift: -g^2(Delta + omega) from counter-rotating terms\nSqueezing terms: a^2 and (a^dagger)^2 that squeeze the cavity field\n\nThe total dispersive shift combines both contributions:\n\nchi_texttotal = -fracg^2Delta - omega - fracg^2Delta + omega\n\n(Image: Bloch-Siegert shift: JC vs full Rabi model)","category":"section"},{"location":"schrieffer_wolff/#N-Level-Atom-in-a-Cavity","page":"Schrieffer-Wolff","title":"N-Level Atom in a Cavity","text":"For atoms with more than two levels, use nlevel_ops:\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# 5-level atom: σ[i,j] = |i⟩⟨j|\nσ5 = nlevel_ops(5, :q)\n\nω = [Symbolics.variable(Symbol(\"ω\", i)) for i in 1:5]\n@variables ωc g\n\n# Atom + cavity + dipole coupling |1⟩↔|3⟩\nH = sum(ω[i] * σ5[i,i] for i in 1:5) + \n    ωc * a'()*a() + \n    g * (σ5[1,3] * a'() + σ5[3,1] * a())\n\n# Zero-photon subspace\nP = Subspace(a'()*a() => 0)\n\nresult = schrieffer_wolff(H, P; order=2)\nshow_result(result)\n\nGenerator:\n\nS = fracgomega_1 - omega_3 - omega_c 1ranglelangle 3  a^dagger + fracgomega_3 - omega_1 + omega_c 3ranglelangle 1  a","category":"section"},{"location":"schrieffer_wolff/#Physical-Interpretation-5","page":"Schrieffer-Wolff","title":"Physical Interpretation","text":"Dispersive shift: chi_13 = g^2(omega_1 - omega_3 + omega_c)\nAC Stark shifts on levels 1 and 3\nOther levels (2, 4, 5) appear only with bare energies","category":"section"},{"location":"schrieffer_wolff/#Three-Level-Lambda-System-(SU(3))","page":"Schrieffer-Wolff","title":"Three-Level Lambda System (SU(3))","text":"For systems with SU(N) symmetry, use su_generators:\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# Gell-Mann matrices for SU(3)\nλ = su_generators(3, :λ)\n\n@variables Δ Ω₁ Ω₂\n\n# Lambda system\nH = Δ * λ[8] + Ω₁ * λ[1] + Ω₂ * λ[4]\n\nP = Subspace(λ[8] => 1/sqrt(3))\n\n# Automatically uses matrix-element method for SU(3)\nresult = schrieffer_wolff(H, P; order=2)\nshow_result(result)\n\nThe package automatically detects SU(3) and uses the matrix-element method.","category":"section"},{"location":"schrieffer_wolff/#When-to-Use-SU(N)-vs-N-Level","page":"Schrieffer-Wolff","title":"When to Use SU(N) vs N-Level","text":"Approach Use When\nnlevel_ops Physical atoms, specific transitions\nsu_generators Systems with SU(N) symmetry\n\n","category":"section"},{"location":"schrieffer_wolff/#Key-Points","page":"Schrieffer-Wolff","title":"Key Points","text":"Always use QuantumAlgebra.use_σpm(true) for SW transformations with spins\nDefine subspace carefully - this determines what \"diagonal\" means\nUse collect_terms to see simplified coefficients\nThe physics is in the coefficients - extract them with extract_coefficient\nN-level and SU(N) systems are automatically handled with appropriate methods\nUse parallel=true for orders 4+ and start Julia with -t 4 or more threads\nUse simplify_mode=:none for maximum speed when exploring\n\n","category":"section"},{"location":"schrieffer_wolff/#Comparison-with-Other-Methods","page":"Schrieffer-Wolff","title":"Comparison with Other Methods","text":"","category":"section"},{"location":"schrieffer_wolff/#vs.-Löwdin-Partitioning","page":"Schrieffer-Wolff","title":"vs. Löwdin Partitioning","text":"Löwdin partitioning (also called quasi-degenerate perturbation theory) achieves the same goal but works directly with the Hamiltonian matrix rather than through a unitary transformation. SW provides the explicit generator S, which can be useful for understanding the transformation and computing other observables.","category":"section"},{"location":"schrieffer_wolff/#vs.-Adiabatic-Elimination","page":"Schrieffer-Wolff","title":"vs. Adiabatic Elimination","text":"Adiabatic elimination assumes fast variables equilibrate instantly. SW is more systematic and provides higher-order corrections, but requires a perturbative expansion.","category":"section"},{"location":"schrieffer_wolff/#vs.-Numerical-Diagonalization","page":"Schrieffer-Wolff","title":"vs. Numerical Diagonalization","text":"Numerical methods give exact eigenvalues but not analytical expressions. SW produces symbolic results like g^2Delta that reveal the parameter dependence and scaling.\n\n","category":"section"},{"location":"schrieffer_wolff/#References","page":"Schrieffer-Wolff","title":"References","text":"J. R. Schrieffer and P. A. Wolff, \"Relation between the Anderson and Kondo Hamiltonians,\" Phys. Rev. 149, 491 (1966).\nS. Bravyi, D. P. DiVincenzo, and D. Loss, \"Schrieffer-Wolff transformation for quantum many-body systems,\" Ann. Phys. 326, 2793 (2011).\nC. Cohen-Tannoudji, J. Dupont-Roc, and G. Grynberg, Atom-Photon Interactions (Wiley, 1998), Chapter 3.\nM. Wagner, Unitary Transformations in Solid State Physics (North-Holland, 1986).","category":"section"},{"location":"#UnitaryTransformations.jl","page":"Home","title":"UnitaryTransformations.jl","text":"A Julia package for performing symbolic unitary transformations on quantum Hamiltonians.\n\n(Image: Summary of Schrieffer-Wolff transformations at different orders)","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"Unitary transformations are essential tools in quantum mechanics for simplifying Hamiltonians, deriving effective low-energy theories, and block-diagonalizing systems with separated energy scales.\n\nThis package provides symbolic implementations that produce analytical expressions rather than numerical results. For example, the dispersive shift in circuit QED is computed as -g²/Δ, not as a floating-point number.","category":"section"},{"location":"#Available-Transformations","page":"Home","title":"Available Transformations","text":"Transformation Purpose Documentation\nSchrieffer-Wolff Block-diagonalize Hamiltonians, derive effective low-energy theories Guide\nMagnus Expansion Effective Hamiltonians for periodically driven (Floquet) systems Guide","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\nQuantumAlgebra.use_σpm(true)\n\n@variables Δ g\n\n# Jaynes-Cummings Hamiltonian\nH = Δ/2 * σz() + g * (a'()*σm() + a()*σp())\n\n# Define the low-energy subspace\nP = Subspace(σz() => -1)\n\n# Perform Schrieffer-Wolff transformation\nresult = schrieffer_wolff(H, P; order=2)\n\nprintln(result.H_P)\n# Output: -Δ/2 + (-g²/Δ) a†a","category":"section"},{"location":"#Supported-Quantum-Systems","page":"Home","title":"Supported Quantum Systems","text":"The package works with quantum systems provided by QuantumAlgebra.jl:\n\nSystem Operators Example\nTwo-level systems σx(), σy(), σz(), σp(), σm() Qubits, spin-1/2\nBosonic modes a(), a'() Cavities, phonons\nN-level atoms nlevel_ops(N, :name) Multi-level atoms\nSU(N) systems su_generators(N, :name) 3-level Λ systems\nFermions f(:name), f'(:name) Electrons\nSymbolic sums SymSum(expr, i), SymExpr Multi-atom systems (Tavis-Cummings)","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/volkerkarle/UnitaryTransformations.jl\")","category":"section"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"Pages = [\"schrieffer_wolff.md\", \"magnus.md\", \"api.md\"]\nDepth = 2","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"If you use this package in your research:\n\n@software{UnitaryTransformations.jl,\n  author = {Karle, Volker},\n  title = {UnitaryTransformations.jl: Symbolic Unitary Transformations for Quantum Hamiltonians},\n  url = {https://github.com/volkerkarle/UnitaryTransformations.jl},\n  year = {2025}\n}","category":"section"}]
}
