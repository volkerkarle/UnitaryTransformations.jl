var documenterSearchIndex = {"docs":
[{"location":"api/#api","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Main-Functions","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api/#Schrieffer-Wolff-Transformation","page":"API Reference","title":"Schrieffer-Wolff Transformation","text":"","category":"section"},{"location":"api/#Subspace-Definition","page":"API Reference","title":"Subspace Definition","text":"","category":"section"},{"location":"api/#Hamiltonian-Decomposition","page":"API Reference","title":"Hamiltonian Decomposition","text":"","category":"section"},{"location":"api/#Generator-Solution","page":"API Reference","title":"Generator Solution","text":"The core operation in Schrieffer-Wolff is solving S H_d = -V_od for the generator S.","category":"section"},{"location":"api/#Main-Function","page":"API Reference","title":"Main Function","text":"","category":"section"},{"location":"api/#Method-Specific-Functions","page":"API Reference","title":"Method-Specific Functions","text":"Two methods are available, automatically selected based on the operator types:","category":"section"},{"location":"api/#Supporting-Functions","page":"API Reference","title":"Supporting Functions","text":"","category":"section"},{"location":"api/#Projection","page":"API Reference","title":"Projection","text":"","category":"section"},{"location":"api/#BCH-Expansion","page":"API Reference","title":"BCH Expansion","text":"The Baker-Campbell-Hausdorff expansion is used to compute e^S H e^-S.\n\n","category":"section"},{"location":"api/#Symbolic-Utilities","page":"API Reference","title":"Symbolic Utilities","text":"","category":"section"},{"location":"api/#Coefficient-Manipulation","page":"API Reference","title":"Coefficient Manipulation","text":"","category":"section"},{"location":"api/#LaTeX-Output","page":"API Reference","title":"LaTeX Output","text":"","category":"section"},{"location":"api/#Parameter-Conversion","page":"API Reference","title":"Parameter Conversion","text":"Functions for converting between QuantumAlgebra's Param and Symbolics.jl variables:\n\n","category":"section"},{"location":"api/#Re-exported-from-QuantumAlgebra","page":"API Reference","title":"Re-exported from QuantumAlgebra","text":"The following functions are re-exported for convenience:\n\ncomm(A, B) - Compute commutator A B = AB - BA\nnormal_form(expr) - Normal-order an operator expression\na(), a'() - Bosonic annihilation/creation operators\nσx(), σy(), σz() - Pauli matrices\nσp(), σm() - Raising/lowering operators (when use_σpm(true))\nnlevel_ops(N, name) - N-level transition operators iranglelangle j\nsu_generators(N, name) - SU(N) generators (generalized Gell-Mann matrices)\n\n","category":"section"},{"location":"api/#Symbolic-Parameters","page":"API Reference","title":"Symbolic Parameters","text":"Use Symbolics.jl @variables to define symbolic parameters:\n\nusing Symbolics\n@variables Δ g ω  # Define symbolic parameters\n\nFor N-level systems with indexed parameters:\n\n# Create ω₁, ω₂, ..., ωₙ\nω = [Symbolics.variable(Symbol(\"ω\", i)) for i in 1:N]\n\n","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#SWResult","page":"API Reference","title":"SWResult","text":"The schrieffer_wolff function returns a named tuple:\n\nresult = schrieffer_wolff(H, P; order=2)\n\nresult.S      # Generator of the transformation\nresult.H_eff  # Block-diagonal effective Hamiltonian  \nresult.H_P    # H_eff projected onto subspace P","category":"section"},{"location":"api/#Subspace","page":"API Reference","title":"Subspace","text":"# Single constraint\nP = Subspace(σz() => -1)\n\n# Multiple constraints\nP = Subspace(σz() => -1, a'()*a() => 0)\n\n# N-level constraint\nP = Subspace(a'()*a() => 0)  # zero photons","category":"section"},{"location":"api/#Classification-Enums","page":"API Reference","title":"Classification Enums","text":"The package uses classification enums for operator analysis:\n\nDIAGONAL   # Operator preserves the subspace\nRAISING    # Operator raises out of subspace P\nLOWERING   # Operator lowers into subspace P\nMIXED      # Operator has mixed character\n\n","category":"section"},{"location":"api/#Internal-Functions","page":"API Reference","title":"Internal Functions","text":"These functions are not exported but may be useful for advanced users:","category":"section"},{"location":"api/#Lie-Algebra-Support","page":"API Reference","title":"Lie Algebra Support","text":"# Get generators for detected Lie algebra\nget_generators_for_lie_system(lie_info::NamedTuple)\n\n# Convert between bases\ngellmann_to_cartan_weyl(V_od, N, algebra_id)\ncartan_weyl_to_gellmann(transitions, N, generators)","category":"section"},{"location":"api/#Operator-Classification","page":"API Reference","title":"Operator Classification","text":"# Classify a single term\nclassify_term(term::QuTerm, coeff, constraints)\n\n# Check if operator contains only specific types\nhas_only_bosons(term::QuTerm)\nhas_only_tls(term::QuTerm)","category":"section"},{"location":"api/#UnitaryTransformations.schrieffer_wolff","page":"API Reference","title":"UnitaryTransformations.schrieffer_wolff","text":"schrieffer_wolff(H::QuExpr, P::Subspace; order::Int=2)\n\nPerform the Schrieffer-Wolff transformation on Hamiltonian H with respect  to the low-energy subspace P.\n\nThe transformation finds a unitary U = e^S such that H_eff = e^S H e^{-S} is block-diagonal with respect to P and Q = 1-P, up to the specified order in perturbation theory.\n\nArguments\n\nH: The full Hamiltonian to transform\nP: The low-energy subspace definition\norder: Perturbation theory order (default: 2)\nsimplify_generator: Whether to simplify the generator S (default: false). Simplifying S can be very slow at high orders due to GCD computations on complex symbolic fractions. Set to true if you need simplified S.\n\nReturns\n\nNamed tuple (H_eff, S, H_P) where:\nH_eff: The full block-diagonal effective Hamiltonian\nS: The generator of the transformation\nH_P: The effective Hamiltonian projected onto subspace P\n\nExample\n\nusing QuantumAlgebra, UnitaryTransformations, Symbolics\n\n# Jaynes-Cummings in dispersive regime\n@variables ω Δ g  # ω = cavity frequency, Δ = qubit splitting, g = coupling strength\n\nH = ω * a'()*a() + Δ/2 * σz() + g * (a'()*σm() + a()*σp())\n\n# Transform to eliminate qubit-photon coupling\nP = Subspace(σz() => -1)  # qubit ground state\nresult = schrieffer_wolff(H, P; order=2)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.sw_generator","page":"API Reference","title":"UnitaryTransformations.sw_generator","text":"sw_generator(H::QuExpr, P::Subspace; order::Int=1)\n\nCompute only the generator S for the Schrieffer-Wolff transformation, without computing the full effective Hamiltonian.\n\nThis is useful when you only need S, or want to manually compute the transformation using bch_transform.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.Subspace","page":"API Reference","title":"UnitaryTransformations.Subspace","text":"Subspace(constraints...)\n\nDefine a low-energy subspace P by specifying constraints on operators.\n\nExamples\n\n# Spin-down subspace\nP = Subspace(σz() => -1)\n\n# Vacuum subspace (zero bosons)\nP = Subspace(a'()*a() => 0)\n\n# Product state: spin-down AND zero bosons\nP = Subspace(σz() => -1, a'()*a() => 0)\n\n# Indexed systems\nP = Subspace(σz(:i) => -1)  # All spins down\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitaryTransformations.OperatorConstraint","page":"API Reference","title":"UnitaryTransformations.OperatorConstraint","text":"OperatorConstraint\n\nA single constraint defining a sector: an operator and its eigenvalue in that sector.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitaryTransformations.decompose","page":"API Reference","title":"UnitaryTransformations.decompose","text":"decompose(H::QuExpr, P::Subspace)\n\nDecompose H into diagonal and off-diagonal parts with respect to subspace P.\n\nReturns (Hd, Hod) where:\n\nH_d is the block-diagonal part\nH_od is the off-block-diagonal part\nH = Hd + Hod\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.diagonal_part","page":"API Reference","title":"UnitaryTransformations.diagonal_part","text":"diagonal_part(H::QuExpr, P::Subspace)\n\nExtract the block-diagonal part of H with respect to subspace P. This includes terms that preserve P (P·H·P) and terms that preserve Q (Q·H·Q).\n\nNote: Terms classified as MIXED (like σx when not using σpm mode) are skipped. For proper handling, ensure Hamiltonians are expressed in the σ± basis.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.off_diagonal_part","page":"API Reference","title":"UnitaryTransformations.off_diagonal_part","text":"off_diagonal_part(H::QuExpr, P::Subspace)\n\nExtract the off-block-diagonal part of H with respect to subspace P. This includes terms that couple P to Q (P·H·Q + Q·H·P).\n\nNote: MIXED terms (like σx in σz basis, or off-diagonal Lie algebra generators) are included in the off-diagonal part since they contain off-diagonal components that couple different subspaces.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.is_diagonal","page":"API Reference","title":"UnitaryTransformations.is_diagonal","text":"is_diagonal(expr::QuExpr, P::Subspace)\n\nCheck if an expression is purely block-diagonal with respect to subspace P.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.is_off_diagonal","page":"API Reference","title":"UnitaryTransformations.is_off_diagonal","text":"is_off_diagonal(expr::QuExpr, P::Subspace)\n\nCheck if an expression is purely off-block-diagonal with respect to subspace P.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.solve_for_generator","page":"API Reference","title":"UnitaryTransformations.solve_for_generator","text":"solve_for_generator(H_d::QuExpr, V_od::QuExpr, P::Subspace)\n\nSolve [S, Hd] = -Vod for the generator S.\n\nThis is the core equation in Schrieffer-Wolff: we need to find S such that the commutator with the diagonal part cancels the off-diagonal perturbation.\n\nTwo methods are automatically selected:\n\nEigenoperator method (TLS, bosons): For operators O where [H_d, O] = ε·O, solve S = O/ε directly.\nMatrix-element method (SU(N) Lie algebras): Work in the Cartan-Weyl basis where transition operators are eigenoperators, compute S{ij} = V{ij}/(Ei - Ej).\n\nUses Symbolics.jl for proper symbolic division, allowing denominators like (Δ - ω).\n\nArguments\n\nH_d: The diagonal (unperturbed) Hamiltonian\nV_od: The off-diagonal perturbation to be eliminated\nP: The subspace defining the block structure\n\nReturns\n\nS: The generator of the transformation\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.solve_for_generator_eigenoperator","page":"API Reference","title":"UnitaryTransformations.solve_for_generator_eigenoperator","text":"solve_for_generator_eigenoperator(H_d::QuExpr, V_od::QuExpr, P::Subspace)\n\nSolve [S, Hd] = -Vod using the eigenoperator method.\n\nThis method works for operators O where [Hd, O] = ε·O (eigenoperators of the adjoint action). Examples include σ± for TLS, and bosonic operators a, a† when Hd is a number operator.\n\nFor each term in Vod, if [Hd, O] = ε·O, then the corresponding term in S is O/ε.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.solve_for_generator_lie","page":"API Reference","title":"UnitaryTransformations.solve_for_generator_lie","text":"solve_for_generator_lie(H_d::QuExpr, V_od::QuExpr, N::Int, generators::Tuple; \n                        algebra_id=SU3_ALGEBRA_ID)\n\nSolve [S, Hd] = -Vod for the generator S using the matrix-element method.\n\nThis approach works for any SU(N) Lie algebra by:\n\nConverting Vod to Cartan-Weyl basis (transition operators E{ij})\nComputing S{ij} = V{ij} / (Eᵢ - Eⱼ) for each transition\nConverting S back to Gell-Mann basis\n\nArguments\n\nH_d: The diagonal Hamiltonian (in diagonal generators only)\nV_od: The off-diagonal perturbation to be eliminated\nN: Dimension of the representation (2 for SU(2), 3 for SU(3))\ngenerators: Tuple of SU(N) generators (from su_generators)\nalgebra_id: The algebra identifier (default: SU3ALGEBRAID)\n\nReturns\n\nS: The generator of the transformation\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.compute_energy_denominator","page":"API Reference","title":"UnitaryTransformations.compute_energy_denominator","text":"compute_energy_denominator(H_d::QuExpr, term::QuTerm, P::Subspace)\n\nCompute the energy denominator for a given off-diagonal term.\n\nFor an off-diagonal operator O, if [Hd, O] = ε·O, then the energy denominator is ε. This is computed by evaluating [Hd, O] and extracting the coefficient.\n\nReturns the energy denominator as a Symbolics Num expression.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.compute_energy_eigenvalues","page":"API Reference","title":"UnitaryTransformations.compute_energy_eigenvalues","text":"compute_energy_eigenvalues(H_d::QuExpr, N::Int, algebra_id::UInt16)\n\nCompute energy eigenvalues for an N-level system from a diagonal Hamiltonian expressed in terms of Lie algebra generators.\n\nFor SU(N), the diagonal generators (Cartan subalgebra) have known eigenvalues. This function extracts the coefficients from H_d and computes Eᵢ for each state.\n\nReturns a vector of symbolic expressions [E₁, E₂, ..., Eₙ].\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.detect_lie_algebra_system","page":"API Reference","title":"UnitaryTransformations.detect_lie_algebra_system","text":"detect_lie_algebra_system(V_od::QuExpr)\n\nDetect if V_od contains Lie algebra generators and return information about the algebra.\n\nReturns nothing if no Lie algebra operators found, or a NamedTuple with:\n\nN: dimension of the algebra (2 for SU(2), 3 for SU(3))\nalgebra_id: the UInt16 algebra identifier\nname: the generator name (e.g., :λ)\ninds: the indices tuple\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.project_to_subspace","page":"API Reference","title":"UnitaryTransformations.project_to_subspace","text":"project_to_subspace(H::QuExpr, P::Subspace)\n\nProject an operator onto the subspace P.\n\nThis replaces diagonal operators by their eigenvalues in P:\n\nσz → eigenvalue (e.g., -1 for spin down)\nσ⁺σ⁻ → 0 for spin down, 1 for spin up\na†a → eigenvalue (e.g., 0 for vacuum)\n\nAnd removes any remaining off-diagonal terms.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.bch_transform","page":"API Reference","title":"UnitaryTransformations.bch_transform","text":"bch_transform(S::QuExpr, A::QuExpr; order::Int=4)\n\nCompute e^S A e^{-S} using the BCH formula to the specified order.\n\nThis computes the adjoint action of e^S on an operator A:     e^S A e^{-S} = A + [S,A] + (1/2!)[S,[S,A]] + (1/3!)[S,[S,[S,A]]] + ...\n\nArguments\n\nS: The generator (typically anti-Hermitian: S† = -S)\nA: The operator to transform (e.g., a Hamiltonian)\norder: Number of nested commutators to include (default: 4)\n\nExample\n\nusing QuantumAlgebra, UnitaryTransformations, Symbolics\n@variables g Δ\n\n# Generator from SW transformation\nS = (g/Δ) * (a'()*σm() - a()*σp())\n\n# Transform the Hamiltonian\nH = Δ/2 * σz() + g * (a'()*σm() + a()*σp())\nH_transformed = bch_transform(S, H; order=2)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.commutator_series","page":"API Reference","title":"UnitaryTransformations.commutator_series","text":"commutator_series(S::QuExpr, H::QuExpr, order::Int)\n\nCompute the BCH expansion of e^S H e^{-S} to the given order.\n\ne^S H e^{-S} = Σₙ (1/n!) [S, [S, [..., [S, H]...]]]  (n nested commutators)\n\nThe expansion is truncated at order nested commutators.\n\nArguments\n\nS: The generator of the unitary transformation (anti-Hermitian: S† = -S)\nH: The operator to transform\norder: Maximum number of nested commutators to include\n\nReturns\n\nThe transformed operator as a QuExpr\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.nested_commutator","page":"API Reference","title":"UnitaryTransformations.nested_commutator","text":"nested_commutator(S::QuExpr, H::QuExpr, n::Int)\n\nCompute the n-fold nested commutator [S, [S, [..., [S, H]...]]] with S appearing n times.\n\nn=0 returns H\nn=1 returns [S, H]\nn=2 returns [S, [S, H]]\netc.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.simplify_coefficients","page":"API Reference","title":"UnitaryTransformations.simplify_coefficients","text":"simplify_coefficients(expr::QuExpr)\n\nSimplify all Symbolics coefficients in a QuExpr. Returns a new QuExpr with simplified coefficients.\n\nUses simplify_fractions which is much faster than full simplify for the rational expressions that arise in Schrieffer-Wolff.\n\nNote: Parallelization was attempted but SymbolicUtils/Symbolics.jl has thread-safety issues that cause race conditions during simplification. The serial version is used for correctness.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.substitute_values","page":"API Reference","title":"UnitaryTransformations.substitute_values","text":"substitute_values(expr::QuExpr, values::Dict{Symbol, Number})\n\nSubstitute numerical values for symbolic parameters in a QuExpr.\n\nArguments\n\nexpr: A QuExpr with symbolic coefficients\nvalues: Dict mapping parameter symbols to numerical values\n\nExample\n\nH_P = result.H_P\nvalues = Dict(:g => 0.1, :Δ => 1.0)\nH_numeric = substitute_values(H_P, values)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.extract_coefficient","page":"API Reference","title":"UnitaryTransformations.extract_coefficient","text":"extract_coefficient(expr::QuExpr, target_ops::QuExpr)\n\nExtract the coefficient of a specific operator structure from a QuExpr.\n\nArguments\n\nexpr: The full QuExpr to search\ntarget_ops: The operator structure to match (e.g., a'()*a())\n\nReturns\n\nThe coefficient (Num or Number) if found, nothing otherwise\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.collect_terms","page":"API Reference","title":"UnitaryTransformations.collect_terms","text":"collect_terms(expr::QuExpr)\n\nCollect and display all terms in a QuExpr with their simplified coefficients. Returns a vector of (operatorstring, simplifiedcoefficient) pairs.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.to_latex","page":"API Reference","title":"UnitaryTransformations.to_latex","text":"to_latex(expr::QuExpr; simplify_coeff::Bool=true)\n\nConvert a QuExpr to a LaTeX string with simplified coefficients.\n\nArguments\n\nexpr: The quantum expression to convert\nsimplify_coeff: Whether to simplify coefficients first (default: true)\n\nReturns\n\nA LaTeX string representation of the expression.\n\nExample\n\nH = Δ/2 * σz() + g * (a'() * σm() + a() * σp())\nprintln(to_latex(H))\n\n\n\n\n\nto_latex(result::NamedTuple; simplify_coeff::Bool=true)\n\nConvert a Schrieffer-Wolff result to LaTeX strings.\n\nReturns\n\nA NamedTuple with LaTeX strings for each component:\n\nH_eff: The effective Hamiltonian\nS: The generator\nH_P: The projected Hamiltonian\n\nExample\n\nresult = schrieffer_wolff(H, P; order=2)\nlatex_result = to_latex(result)\nprintln(latex_result.H_P)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.print_latex","page":"API Reference","title":"UnitaryTransformations.print_latex","text":"print_latex(expr::QuExpr; name::String=\"\", display::Bool=true, simplify_coeff::Bool=true)\n\nPrint a QuExpr as LaTeX, optionally wrapped in display math environment.\n\nArguments\n\nexpr: The quantum expression to print\nname: Optional name to show (e.g., \"H_{eff}\")\ndisplay: If true, wrap in \\[ ... \\] for display math\nsimplify_coeff: Whether to simplify coefficients first\n\nExample\n\nprint_latex(result.H_P; name=\"H_P\")\n# Output: H_P = - \\frac{1}{2} \\Delta + ...\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.show_result","page":"API Reference","title":"UnitaryTransformations.show_result","text":"show_result(result::NamedTuple; display::Bool=false, simplify_coeff::Bool=true)\n\nPretty-print all components of a Schrieffer-Wolff result in LaTeX.\n\nArguments\n\nresult: The result from schrieffer_wolff\ndisplay: If true, wrap each in display math environment\nsimplify_coeff: Whether to simplify coefficients\n\nExample\n\nresult = schrieffer_wolff(H, P; order=2)\nshow_result(result)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.param_to_symbolic","page":"API Reference","title":"UnitaryTransformations.param_to_symbolic","text":"param_to_symbolic(p::Param)\n\nConvert a QuantumAlgebra Param to a Symbolics variable. Caches variables to ensure the same param always maps to the same variable.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.symbolic_coefficient","page":"API Reference","title":"UnitaryTransformations.symbolic_coefficient","text":"symbolic_coefficient(term::QuTerm, coeff::Number)\n\nConvert a QuTerm's coefficient (Number + Params) to a single Symbolics expression. Handles both real and complex coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.clear_param_cache!","page":"API Reference","title":"UnitaryTransformations.clear_param_cache!","text":"clear_param_cache!()\n\nClear the parameter to Symbolics variable cache. Useful when starting a new calculation with fresh variables.\n\n\n\n\n\n","category":"function"},{"location":"theory/#theory","page":"Theory","title":"Theory","text":"This section provides the mathematical background for the unitary transformations implemented in this package.","category":"section"},{"location":"theory/#Unitary-Transformations-in-Quantum-Mechanics","page":"Theory","title":"Unitary Transformations in Quantum Mechanics","text":"A unitary transformation maps a Hamiltonian H to a new Hamiltonian tildeH via:\n\ntildeH = U H U^dagger\n\nwhere U is a unitary operator (U^dagger U = mathbb1). The physics is unchanged—the eigenvalues are preserved—but the representation may be simpler or more convenient.\n\nWhen U = e^S for some anti-Hermitian generator S (i.e., S^dagger = -S), the transformed Hamiltonian can be expanded using the Baker-Campbell-Hausdorff (BCH) formula:\n\ne^S H e^-S = H + S H + frac12S S H + frac13S S S H + cdots\n\nThis infinite series becomes tractable when S is small (perturbative) or when the series terminates after a finite number of terms.\n\n","category":"section"},{"location":"theory/#sw_transformation","page":"Theory","title":"Schrieffer-Wolff Transformation","text":"The Schrieffer-Wolff (SW) transformation is a perturbative method for block-diagonalizing Hamiltonians with well-separated energy scales. It was introduced by Schrieffer and Wolff in 1966 to derive the Kondo exchange interaction from the Anderson impurity model.","category":"section"},{"location":"theory/#The-Problem","page":"Theory","title":"The Problem","text":"Consider a Hamiltonian of the form:\n\nH = H_0 + V\n\nwhere:\n\nH_0 is the unperturbed Hamiltonian with known eigenstates grouped into low-energy (P) and high-energy (Q) sectors\nV is a perturbation that couples the P and Q sectors\n\nWe want to find an effective Hamiltonian H_texteff that:\n\nActs only within the low-energy sector P\nCaptures the effects of V to a given order in perturbation theory","category":"section"},{"location":"theory/#The-Transformation","page":"Theory","title":"The Transformation","text":"We seek a unitary U = e^S such that the transformed Hamiltonian:\n\nH_texteff = e^S H e^-S\n\nis block-diagonal with respect to the P and Q subspaces. This means H_texteff has no matrix elements connecting P and Q.","category":"section"},{"location":"theory/#Determining-the-Generator","page":"Theory","title":"Determining the Generator","text":"Decompose the Hamiltonian and generator into block-diagonal and off-block-diagonal parts:\n\nH = H_d + V_od quad S = S_od\n\nwhere:\n\nH_d = P H P + Q H Q (block-diagonal)\nV_od = P H Q + Q H P (off-block-diagonal)\nS_od is purely off-block-diagonal (anti-Hermitian)\n\nThe generator equation at first order is:\n\nS H_d = -V_od\n\nThis is the fundamental equation that determines S. It states that the commutator of S with the diagonal Hamiltonian must cancel the off-diagonal perturbation.","category":"section"},{"location":"theory/#Solving-the-Generator-Equation","page":"Theory","title":"Solving the Generator Equation","text":"For operators O that are eigenoperators of the adjoint action of H_d—meaning H_d O = varepsilon cdot O for some energy varepsilon—the solution is:\n\nS = sum_alpha fracV_alphavarepsilon_alpha\n\nwhere V_alpha are the components of V_od and varepsilon_alpha are the corresponding energy denominators.\n\nExample: For a two-level system with H_d = fracDelta2sigma_z and V_od = gsigma^+:\n\nsigma_z sigma^+ = 2sigma^+, so H_d sigma^+ = Deltasigma^+\nTherefore S = fracgDeltasigma^+ (plus Hermitian conjugate for the sigma^- term)","category":"section"},{"location":"theory/#The-Effective-Hamiltonian","page":"Theory","title":"The Effective Hamiltonian","text":"Using the BCH expansion:\n\nH_texteff = H_d + frac12S V_od + O(V^3)\n\nThe key second-order contribution is:\n\nH^(2) = frac12S V_od\n\nThis generates effective interactions within the low-energy sector that arise from virtual transitions to high-energy states.","category":"section"},{"location":"theory/#Physical-Interpretation","page":"Theory","title":"Physical Interpretation","text":"The SW transformation captures the physics of virtual processes:\n\nThe system starts in the low-energy sector P\nThe perturbation V virtually excites it to high-energy sector Q\nThe system returns to P via another application of V\n\nThis virtual excitation costs energy Delta E and contributes to the effective Hamiltonian as sim V^2Delta E.","category":"section"},{"location":"theory/#Order-by-Order-Expansion","page":"Theory","title":"Order-by-Order Expansion","text":"At higher orders, the SW transformation proceeds iteratively:\n\nOrder Contribution Energy dependence\n0 H_d Original diagonal\n2 frac12S_1 V sim g^2Delta\n3 frac12S_1 S_1 H_d + S_2 V sim g^3Delta^2\n4 Higher nested commutators sim g^4Delta^3\n\nEach order adds terms suppressed by additional powers of gDelta.\n\n","category":"section"},{"location":"theory/#Eigenoperator-Method","page":"Theory","title":"Eigenoperator Method","text":"This package implements two methods for solving the generator equation. The eigenoperator method works for operators that satisfy:\n\nH_d O = varepsilon cdot O\n\nSuch operators are called eigenoperators of the Liouvillian mathcalL_H_d(cdot) = H_d cdot.","category":"section"},{"location":"theory/#Examples-of-Eigenoperators","page":"Theory","title":"Examples of Eigenoperators","text":"System Operator Eigenvalue\nTLS: H_d = fracDelta2sigma_z sigma^+ +Delta\n sigma^- -Delta\nCavity: H_d = omega a^dagger a a^dagger +omega\n a -omega\nN-level: H_d = sum_i E_i vert iranglelangle ivert vert iranglelangle jvert E_i - E_j\n\nFor these operators, the generator is simply:\n\nS = fracOvarepsilon","category":"section"},{"location":"theory/#Composite-Operators","page":"Theory","title":"Composite Operators","text":"Products of eigenoperators are also eigenoperators with additive eigenvalues:\n\nH_d O_1 O_2 = (varepsilon_1 + varepsilon_2) O_1 O_2\n\nExample: For the Jaynes-Cummings interaction a^dagger sigma^-:\n\nH_d a^dagger sigma^- = (omega_c - Delta) a^dagger sigma^-\nEnergy denominator: omega_c - Delta (the detuning)\n\n","category":"section"},{"location":"theory/#Matrix-Element-Method-for-Lie-Algebras","page":"Theory","title":"Matrix-Element Method for Lie Algebras","text":"For SU(N) systems expressed in the Gell-Mann basis, the generators are not eigenoperators of the diagonal Hamiltonian. For example:\n\nlambda_8 lambda_2 neq c cdot lambda_2\n\nInstead, the commutator produces a linear combination of generators.","category":"section"},{"location":"theory/#Cartan-Weyl-Basis","page":"Theory","title":"Cartan-Weyl Basis","text":"The solution is to work in the Cartan-Weyl basis, where the off-diagonal generators are replaced by transition operators:\n\nGell-Mann Cartan-Weyl\nlambda_1 lambda_4 E_12 = vert 1ranglelangle 2vert, E_21 = vert 2ranglelangle 1vert\nlambda_2 lambda_5 E_13 = vert 1ranglelangle 3vert, E_31 = vert 3ranglelangle 1vert\nlambda_3 lambda_6 E_23 = vert 2ranglelangle 3vert, E_32 = vert 3ranglelangle 2vert\n\nThe transition operators are eigenoperators:\n\nH_d vert iranglelangle jvert = (E_i - E_j)vert iranglelangle jvert","category":"section"},{"location":"theory/#Algorithm","page":"Theory","title":"Algorithm","text":"Compute energy eigenvalues E_i from the diagonal Hamiltonian\nConvert V_od from Gell-Mann to Cartan-Weyl basis\nApply inverse Liouvillian: S_ij = V_ij  (E_i - E_j)\nConvert S back to Gell-Mann basis\n\nThis is implemented in solve_for_generator_lie().\n\n","category":"section"},{"location":"theory/#Energy-Denominators","page":"Theory","title":"Energy Denominators","text":"The energy denominators in SW transformations have important physical meaning:","category":"section"},{"location":"theory/#Resonance-Condition","page":"Theory","title":"Resonance Condition","text":"When an energy denominator approaches zero (varepsilon to 0), the perturbation theory breaks down. This indicates a resonance where the two sectors are no longer well-separated.","category":"section"},{"location":"theory/#Example:-Dispersive-Regime","page":"Theory","title":"Example: Dispersive Regime","text":"In circuit QED, the Jaynes-Cummings Hamiltonian has energy denominator Delta = omega_q - omega_c. The dispersive approximation is valid when:\n\ng ll Delta\n\nThe effective Hamiltonian contains the dispersive shift:\n\nchi = -fracg^2Delta\n\nThis diverges as Delta to 0 (resonance), signaling the breakdown of the perturbative treatment.\n\n","category":"section"},{"location":"theory/#Comparison-with-Other-Methods","page":"Theory","title":"Comparison with Other Methods","text":"","category":"section"},{"location":"theory/#vs.-Löwdin-Partitioning","page":"Theory","title":"vs. Löwdin Partitioning","text":"Löwdin partitioning (also called quasi-degenerate perturbation theory) achieves the same goal but works directly with the Hamiltonian matrix rather than through a unitary transformation. SW provides the explicit generator S, which can be useful for understanding the transformation and computing other observables.","category":"section"},{"location":"theory/#vs.-Adiabatic-Elimination","page":"Theory","title":"vs. Adiabatic Elimination","text":"Adiabatic elimination assumes fast variables equilibrate instantly. SW is more systematic and provides higher-order corrections, but requires a perturbative expansion.","category":"section"},{"location":"theory/#vs.-Numerical-Diagonalization","page":"Theory","title":"vs. Numerical Diagonalization","text":"Numerical methods give exact eigenvalues but not analytical expressions. SW produces symbolic results like g^2Delta that reveal the parameter dependence and scaling.\n\n","category":"section"},{"location":"theory/#References","page":"Theory","title":"References","text":"J. R. Schrieffer and P. A. Wolff, \"Relation between the Anderson and Kondo Hamiltonians,\" Phys. Rev. 149, 491 (1966).\nS. Bravyi, D. P. DiVincenzo, and D. Loss, \"Schrieffer-Wolff transformation for quantum many-body systems,\" Ann. Phys. 326, 2793 (2011).\nC. Cohen-Tannoudji, J. Dupont-Roc, and G. Grynberg, Atom-Photon Interactions (Wiley, 1998), Chapter 3.\nM. Wagner, Unitary Transformations in Solid State Physics (North-Holland, 1986).","category":"section"},{"location":"examples/#examples","page":"Examples","title":"Examples","text":"This page presents complete physics examples demonstrating the package capabilities.","category":"section"},{"location":"examples/#Jaynes-Cummings:-Dispersive-Regime","page":"Examples","title":"Jaynes-Cummings: Dispersive Regime","text":"The Jaynes-Cummings model describes a two-level atom coupled to a single cavity mode:\n\nH = omega_c a^dagger a + fracomega_q2sigma_z + g(a^daggersigma^- + asigma^+)\n\nIn the dispersive regime (Delta = omega_q - omega_c gg g), the Schrieffer-Wolff transformation yields an effective Hamiltonian with a state-dependent frequency shift.\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\nQuantumAlgebra.use_σpm(true)\n\n# Define symbolic parameters\n@variables Δ g  # Δ = detuning ω_q - ω_c, g = coupling\n\n# Hamiltonian (in frame rotating at ω_c)\nH = Δ/2 * σz() + g * (a'()*σm() + a()*σp())\n\n# Ground state subspace\nP = Subspace(σz() => -1)\n\n# Transform\nresult = schrieffer_wolff(H, P; order=2)\n\n# Results\nprintln(\"Effective Hamiltonian:\")\nfor (op, coeff) in collect_terms(result.H_eff)\n    println(\"  \", coeff, \"  \", op)\nend","category":"section"},{"location":"examples/#Physical-Interpretation","page":"Examples","title":"Physical Interpretation","text":"The effective Hamiltonian contains:\n\nDispersive shift: chi = g^2Delta \nCavity frequency shifts by pmchi depending on qubit state\nUsed for qubit readout in circuit QED\nAC Stark shift: Qubit frequency shifts with photon number\nomega_q to omega_q + 2chi langle a^dagger a rangle","category":"section"},{"location":"examples/#Numerical-Verification","page":"Examples","title":"Numerical Verification","text":"# Compare with expected value\nχ = extract_coefficient(result.H_P, a'()*a())\nprintln(\"Computed χ = \", χ)\nprintln(\"Expected:  -g²/Δ\")\n\n# Substitute values\nχ_num = substitute_values(result.H_P, Dict(:g => 0.1, :Δ => 1.0))\nprintln(\"χ(g=0.1, Δ=1) = -0.01  # matches -g²/Δ!\")\n\n","category":"section"},{"location":"examples/#Two-Level-System-with-Transverse-Field","page":"Examples","title":"Two-Level System with Transverse Field","text":"A qubit in longitudinal and transverse magnetic fields:\n\nH = fracDelta2sigma_z + varepsilonsigma_x\n\nThis is a textbook quantum mechanics problem with exact solution, making it perfect for verification.\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\nQuantumAlgebra.use_σpm(true)\n\n# Define symbolic parameters\n@variables Δ ε  # Δ = longitudinal field (energy splitting), ε = transverse field (perturbation)\n\n# Hamiltonian: σx = σ⁺ + σ⁻\nH = Δ/2 * σz() + ε * (σp() + σm())\n\n# Ground state subspace\nP = Subspace(σz() => -1)\n\n# Transform\nresult = schrieffer_wolff(H, P; order=2)\n\nprintln(\"Projected Hamiltonian H_P:\")\nfor (op, coeff) in collect_terms(result.H_P)\n    println(\"  \", coeff, \"  \", op)\nend","category":"section"},{"location":"examples/#Comparison-with-Exact-Solution","page":"Examples","title":"Comparison with Exact Solution","text":"The exact eigenvalues are:\n\nE_pm = pmsqrtDelta^24 + varepsilon^2\n\nThe SW result for the ground state energy is:\n\nE_g = -fracDelta2 - fracvarepsilon^2Delta + O(varepsilon^4)\n\n# Numerical comparison\nfor ε_val in [0.01, 0.05, 0.1, 0.2]\n    Δ_val = 1.0\n    E_exact = -sqrt(Δ_val^2/4 + ε_val^2)\n    E_SW = -Δ_val/2 - ε_val^2/Δ_val\n    error = 100 * abs(E_exact - E_SW) / abs(E_exact)\n    println(\"ε/Δ = $ε_val: error = $(round(error, digits=4))%\")\nend\n\nOutput:\n\nε/Δ = 0.01: error = 0.0%\nε/Δ = 0.05: error = 0.0012%\nε/Δ = 0.1: error = 0.0192%\nε/Δ = 0.2: error = 0.2755%\n\nThe perturbative result is excellent when varepsilon ll Delta!\n\n","category":"section"},{"location":"examples/#Rabi-Model:-Bloch-Siegert-Shift","page":"Examples","title":"Rabi Model: Bloch-Siegert Shift","text":"The full Rabi model includes counter-rotating terms that are neglected in the rotating-wave approximation:\n\nH = omega a^dagger a + fracDelta2sigma_z + g(sigma^+ + sigma^-)(a + a^dagger)\n\nThe counter-rotating terms (a^daggersigma^+ and asigma^-) lead to the Bloch-Siegert shift.\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\nQuantumAlgebra.use_σpm(true)\n\n# Define symbolic parameters\n@variables ω Δ g  # ω = oscillator frequency, Δ = qubit splitting, g = coupling\n\n# Full Rabi Hamiltonian (no RWA)\nH_rabi = ω * a'()*a() + Δ/2 * σz() + g * (σp() + σm()) * (a() + a'())\n\n# For comparison: Jaynes-Cummings (with RWA)\nH_jc = ω * a'()*a() + Δ/2 * σz() + g * (a'()*σm() + a()*σp())\n\nP = Subspace(σz() => -1)\n\nresult_rabi = schrieffer_wolff(H_rabi, P; order=2)\nresult_jc = schrieffer_wolff(H_jc, P; order=2)\n\nprintln(\"Full Rabi model produces additional terms:\")\nprintln(\"  - Squeezing terms: a², (a†)²\")\nprintln(\"  - Modified dispersive shift\")","category":"section"},{"location":"examples/#Bloch-Siegert-Correction","page":"Examples","title":"Bloch-Siegert Correction","text":"The counter-rotating terms contribute an additional frequency shift:\n\nchi_BS approx fracg^2Delta + 2omega\n\nThis is typically small (~1% of the JC dispersive shift) but measurable in precision experiments.\n\n","category":"section"},{"location":"examples/#N-Level-Atom-in-a-Cavity","page":"Examples","title":"N-Level Atom in a Cavity","text":"For atoms with more than two levels, use nlevel_ops from QuantumAlgebra. This example shows a 5-level atom with a single dipole-allowed transition coupled to a cavity.\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# 5-level atom: σ[i,j] = |i⟩⟨j| transition operator\nσ5 = nlevel_ops(5, :q)\n\n# Level energies (symbolic)\nω = [Symbolics.variable(Symbol(\"ω\", i)) for i in 1:5]\n@variables ωc g\n\n# Hamiltonian: atom + cavity + coupling between levels 1 and 3\nH = sum(ω[i] * σ5[i,i] for i in 1:5) +    # atomic levels\n    ωc * a'()*a() +                        # cavity\n    g * (σ5[1,3] * a'() + σ5[3,1] * a())  # dipole coupling |1⟩↔|3⟩\n\n# Zero-photon subspace\nP = Subspace(a'()*a() => 0)\n\n# Perform SW transformation\nresult = schrieffer_wolff(H, P; order=2)\n\nprintln(\"Generator S:\")\nprintln(result.S)\n\nprintln(\"\\nEffective Hamiltonian:\")\nprintln(result.H_eff)","category":"section"},{"location":"examples/#Physical-Interpretation-2","page":"Examples","title":"Physical Interpretation","text":"The effective Hamiltonian contains:\n\nDispersive shift on cavity: The cavity frequency shifts depending on atomic state\nchi_13 = fracg^2omega_1 - omega_3 + omega_c\nAC Stark shifts on atomic levels: Levels 1 and 3 experience light shifts proportional to langle a^dagger a rangle\nOther levels unaffected: Levels 2, 4, 5 only appear with their bare energies (to second order)\n\n","category":"section"},{"location":"examples/#Multi-Level-Atom-with-Multiple-Couplings","page":"Examples","title":"Multi-Level Atom with Multiple Couplings","text":"A more realistic model includes multiple dipole-allowed transitions:\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# 7-level atom\nσ7 = nlevel_ops(7, :q)\n\n# Level energies\nω = [Symbolics.variable(Symbol(\"ω\", i)) for i in 1:7]\n@variables ωc g₁₃ g₂₅\n\n# Hamiltonian with two transitions\nH = sum(ω[i] * σ7[i,i] for i in 1:7) +\n    ωc * a'()*a() +\n    g₁₃ * (σ7[1,3] * a'() + σ7[3,1] * a()) +  # |1⟩↔|3⟩\n    g₂₅ * (σ7[2,5] * a'() + σ7[5,2] * a())    # |2⟩↔|5⟩\n\nP = Subspace(a'()*a() => 0)\nresult = schrieffer_wolff(H, P; order=2)\n\n# Extract individual dispersive shifts\n# Each transition contributes independently\nprintln(\"H_eff contains terms from both transitions\")","category":"section"},{"location":"examples/#Selection-Rules","page":"Examples","title":"Selection Rules","text":"The SW transformation respects selection rules:\n\nOnly directly coupled levels acquire dispersive shifts\nCross-terms between different transitions appear only at higher orders\n\n","category":"section"},{"location":"examples/#Three-Level-Lambda-System-(SU(3))","page":"Examples","title":"Three-Level Lambda System (SU(3))","text":"For systems with SU(N) symmetry, the package automatically uses the matrix-element method:\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# SU(3) generators (Gell-Mann matrices)\nλ = su_generators(3, :λ)\n\n@variables Δ Ω₁ Ω₂\n\n# Lambda system:\n# - λ₈ ~ diagonal (level splittings)\n# - λ₁, λ₂ ~ transitions between levels 1↔2\n# - λ₄, λ₅ ~ transitions between levels 1↔3\nH = Δ * λ[8] + Ω₁ * λ[1] + Ω₂ * λ[4]\n\n# Subspace with specific λ₈ eigenvalue\nP = Subspace(λ[8] => 1/sqrt(3))\n\n# Auto-detects SU(3) and uses matrix-element method\nresult = schrieffer_wolff(H, P; order=2)\n\nprintln(\"Generator:\")\nprintln(result.S)\nprintln(\"\\nEffective Hamiltonian:\")\nprintln(result.H_eff)","category":"section"},{"location":"examples/#When-to-Use-SU(N)-vs-N-Level","page":"Examples","title":"When to Use SU(N) vs N-Level","text":"Approach Use When\nnlevel_ops Physical multilevel atoms, specific transitions\nsu_generators Systems with SU(N) symmetry, collective operators\n\nBoth approaches give equivalent physics but may produce differently structured results.\n\n","category":"section"},{"location":"examples/#Running-the-Examples","page":"Examples","title":"Running the Examples","text":"The complete example files are in the examples/ directory:\n\ncd UnitaryTransformations.jl\njulia --project examples/jaynes_cummings_dispersive.jl\njulia --project examples/two_level_system.jl\njulia --project examples/rabi_bloch_siegert.jl\njulia --project examples/three_level_atom.jl\n\nEach example includes detailed physical interpretation and numerical verification.\n\n","category":"section"},{"location":"examples/#Tips-for-New-Examples","page":"Examples","title":"Tips for New Examples","text":"Start simple: Begin with a minimal Hamiltonian and add complexity\nCheck subspace definition: The choice of P determines the entire structure\nVerify with limits: Check known limits (e.g., g to 0)\nUse collect_terms: Helps identify the physical meaning of each term\nCompare orders: Running at different orders helps assess convergence","category":"section"},{"location":"#UnitaryTransformations.jl","page":"Home","title":"UnitaryTransformations.jl","text":"A Julia package for performing symbolic unitary transformations on quantum Hamiltonians.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"Unitary transformations are essential tools in quantum mechanics for:\n\nSimplifying Hamiltonians by eliminating unwanted couplings\nDeriving effective theories that capture low-energy physics\nBlock-diagonalizing systems with separated energy scales\nChanging to more convenient representations (e.g., polaron frame)\n\nThis package provides symbolic implementations that produce analytical expressions rather than numerical results. For example, the dispersive shift in circuit QED is computed as -g²/Δ, not as a floating-point number.","category":"section"},{"location":"#Available-Transformations","page":"Home","title":"Available Transformations","text":"Transformation Purpose Status\nSchrieffer-Wolff Block-diagonalize Hamiltonians, derive effective low-energy theories ✓ Implemented\nLang-Firsov Eliminate linear electron-phonon coupling (polaron frame) Planned\nBogoliubov Diagonalize quadratic bosonic Hamiltonians Planned\nHolstein-Primakoff Map spin operators to bosonic operators Planned","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# Use σ± basis (recommended)\nQuantumAlgebra.use_σpm(true)\n\n# Define symbolic parameters\n@variables Δ g\n\n# Jaynes-Cummings Hamiltonian\nH = Δ/2 * σz() + g * (a'()*σm() + a()*σp())\n\n# Define the low-energy subspace\nP = Subspace(σz() => -1)  # qubit ground state\n\n# Perform Schrieffer-Wolff transformation\nresult = schrieffer_wolff(H, P; order=2)\n\n# The effective Hamiltonian\nprintln(result.H_P)\n# Output: -Δ/2 + (-g²/Δ) a†a","category":"section"},{"location":"#Supported-Quantum-Systems","page":"Home","title":"Supported Quantum Systems","text":"The package works with a variety of quantum systems provided by QuantumAlgebra.jl:\n\nSystem Operators Example\nTwo-level systems σx(), σy(), σz(), σp(), σm() Qubits, spin-1/2\nBosonic modes a(), a'() Cavities, phonons\nN-level atoms nlevel_ops(N, :name) Multi-level atoms\nSU(N) systems su_generators(N, :name) 3-level Λ systems\nFermions f(:name), f'(:name) Electrons\n\nThese can be combined freely—for example, an N-level atom coupled to a bosonic cavity.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/volkerkarle/UnitaryTransformations.jl\")\n\nDependencies (automatically installed):\n\nQuantumAlgebra.jl — Symbolic quantum operator algebra\nSymbolics.jl — Computer algebra system","category":"section"},{"location":"#Documentation-Structure","page":"Home","title":"Documentation Structure","text":"Pages = [\"theory.md\", \"tutorial.md\", \"examples.md\", \"api.md\"]\nDepth = 1","category":"section"},{"location":"#[Theory](@ref-theory)","page":"Home","title":"Theory","text":"Mathematical background on unitary transformations, including the Schrieffer-Wolff method and the Baker-Campbell-Hausdorff formula.","category":"section"},{"location":"#[Tutorial](@ref-tutorial)","page":"Home","title":"Tutorial","text":"Step-by-step guide to using the Schrieffer-Wolff transformation.","category":"section"},{"location":"#[Examples](@ref-examples)","page":"Home","title":"Examples","text":"Physics applications: Jaynes-Cummings, Rabi model, multi-level atoms.","category":"section"},{"location":"#[API-Reference](@ref-api)","page":"Home","title":"API Reference","text":"Complete function documentation.","category":"section"},{"location":"#Package-Philosophy","page":"Home","title":"Package Philosophy","text":"Symbolic over numeric: Results are analytical expressions that can be simplified, manipulated, and substituted.\nAutomatic method selection: The package chooses the optimal algorithm based on the operator types present.\nExtensible design: New transformations can be added as separate modules while sharing the infrastructure.\nVerified correctness: Extensive tests verify mathematical identities and compare with known results.","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"If you use this package in your research:\n\n@software{UnitaryTransformations.jl,\n  author = {Karle, Volker},\n  title = {UnitaryTransformations.jl: Symbolic Unitary Transformations for Quantum Hamiltonians},\n  url = {https://github.com/volkerkarle/UnitaryTransformations.jl},\n  year = {2025}\n}","category":"section"},{"location":"tutorial/#tutorial","page":"Tutorial","title":"Tutorial","text":"This tutorial walks through the Schrieffer-Wolff transformation step by step. For the mathematical background, see the Theory page.","category":"section"},{"location":"tutorial/#Overview","page":"Tutorial","title":"Overview","text":"The Schrieffer-Wolff (SW) transformation finds an effective Hamiltonian that acts within a chosen subspace by perturbatively eliminating couplings to other subspaces. This is useful when:\n\nYou have a system with well-separated energy scales\nYou want to derive an effective low-energy theory\nYou need analytical expressions for perturbative corrections","category":"section"},{"location":"tutorial/#Step-1:-Set-Up-the-System","page":"Tutorial","title":"Step 1: Set Up the System","text":"Let's work with a concrete example: a two-level system (qubit) coupled to a harmonic oscillator (the Jaynes-Cummings model).\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# Use σ± basis - important for SW to work correctly with spins\nQuantumAlgebra.use_σpm(true)\n\n# Define symbolic parameters\n@variables Δ g  # Δ = qubit-oscillator detuning, g = coupling strength\n\n# Jaynes-Cummings Hamiltonian (in rotating frame)\nH = Δ/2 * σz() + g * (a'()*σm() + a()*σp())\n\nThe Hamiltonian describes:\n\nA qubit with splitting Delta (the sigma_z term)\nCoupling to an oscillator mode (the a^dagger sigma^- and a sigma^+ terms)","category":"section"},{"location":"tutorial/#Step-2:-Define-the-Subspace","page":"Tutorial","title":"Step 2: Define the Subspace","text":"We need to specify which states belong to the low-energy subspace P. For this example, we choose the qubit ground state:\n\n# P = states where σz = -1 (qubit in ground state |g⟩)\nP = Subspace(σz() => -1)\n\nThe Subspace type specifies expectation values of operators in the subspace. Here, we say that in subspace P, the operator sigma_z has eigenvalue -1.","category":"section"},{"location":"tutorial/#Multiple-Constraints","page":"Tutorial","title":"Multiple Constraints","text":"For more complex systems, you can specify multiple constraints:\n\n# Subspace with qubit ground state AND zero photons\nP = Subspace(σz() => -1, a'()*a() => 0)","category":"section"},{"location":"tutorial/#Step-3:-Understand-the-Decomposition","page":"Tutorial","title":"Step 3: Understand the Decomposition","text":"The SW transformation requires splitting H into diagonal and off-diagonal parts with respect to P:\n\nH_d, V_od = decompose(H, P)\n\nprintln(\"Diagonal:     \", H_d)\nprintln(\"Off-diagonal: \", V_od)\n\nOutput:\n\nDiagonal:     -0.5Δ + Δ σ⁺σ⁻\nOff-diagonal: g a†σ⁻ + g a σ⁺\n\nDiagonal (H_d): Operators that don't change the subspace (like sigma^+sigma^-, a^dagger a)\nOff-diagonal (V_od): Operators that connect P and Q subspaces (like sigma^+, sigma^-)","category":"section"},{"location":"tutorial/#Step-4:-Perform-the-Transformation","page":"Tutorial","title":"Step 4: Perform the Transformation","text":"Now apply the Schrieffer-Wolff transformation:\n\nresult = schrieffer_wolff(H, P; order=2)\n\nThis returns a named tuple with:\n\nresult.S - The generator of the unitary transformation e^S\nresult.H_eff - The block-diagonal effective Hamiltonian\nresult.H_P - The effective Hamiltonian projected onto subspace P","category":"section"},{"location":"tutorial/#Higher-Orders","page":"Tutorial","title":"Higher Orders","text":"You can go to higher orders for more accuracy:\n\nresult_4th = schrieffer_wolff(H, P; order=4)\n\nNote: Higher orders produce more complex expressions and take longer to compute.","category":"section"},{"location":"tutorial/#Step-5:-Analyze-the-Results","page":"Tutorial","title":"Step 5: Analyze the Results","text":"","category":"section"},{"location":"tutorial/#The-Generator","page":"Tutorial","title":"The Generator","text":"println(\"Generator S = \", result.S)\n# S = (g/Δ) a†σ⁻ + (-g/Δ) a σ⁺\n\nThe generator S is anti-Hermitian (S^dagger = -S) and satisfies:\n\nS H_d = -V_od","category":"section"},{"location":"tutorial/#The-Effective-Hamiltonian","page":"Tutorial","title":"The Effective Hamiltonian","text":"# Collect and display all terms with simplified coefficients\nterms = collect_terms(result.H_eff)\nfor (op, coeff) in terms\n    println(\"  \", coeff, \"  \", op)\nend\n\nOutput:\n\n  -0.5Δ        𝟙\n  -(g²)/Δ      a†a\n  Δ + (g²)/Δ   σ⁺σ⁻\n  ...","category":"section"},{"location":"tutorial/#The-Projected-Hamiltonian","page":"Tutorial","title":"The Projected Hamiltonian","text":"For many applications, we only care about the subspace P:\n\nprintln(\"H_P = \", result.H_P)\n# H_P = -0.5Δ + (-(g²)/Δ) a†a\n\nThis is the dispersive Hamiltonian: the cavity frequency is shifted by -g^2Delta when the qubit is in the ground state!","category":"section"},{"location":"tutorial/#Step-6:-Extract-Physical-Parameters","page":"Tutorial","title":"Step 6: Extract Physical Parameters","text":"Use utility functions to extract specific coefficients:\n\n# Get the dispersive shift (coefficient of a†a)\nχ = extract_coefficient(result.H_P, a'()*a())\nprintln(\"Dispersive shift χ = \", χ)\n# Output: -(g²)/Δ","category":"section"},{"location":"tutorial/#Step-7:-Numerical-Evaluation","page":"Tutorial","title":"Step 7: Numerical Evaluation","text":"Substitute numerical values to get concrete numbers:\n\nH_numeric = substitute_values(result.H_P, Dict(:g => 0.1, :Δ => 1.0))\nprintln(\"H_P with g=0.1, Δ=1.0: \", H_numeric)","category":"section"},{"location":"tutorial/#Step-8:-LaTeX-Output","page":"Tutorial","title":"Step 8: LaTeX Output","text":"For publications and documentation, you can output results in LaTeX:\n\n# Convert a single expression to LaTeX\nprintln(to_latex(result.H_P))\n# Output: - \\frac{1}{2} \\Delta + \\frac{-g^{2}}{\\Delta} {a}^{\\dagger} {a}\n\n# Pretty-print with a name\nprint_latex(result.H_P; name=\"H_P\")\n# Output: H_P = - \\frac{1}{2} \\Delta + \\frac{-g^{2}}{\\Delta} {a}^{\\dagger} {a}\n\n# Show all components of the result\nshow_result(result)\n\nThe show_result function prints the generator S, effective Hamiltonian H_texteff, and projected Hamiltonian H_P in LaTeX format.","category":"section"},{"location":"tutorial/#Complete-Example","page":"Tutorial","title":"Complete Example","text":"Here's the full code:\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# Setup\nQuantumAlgebra.use_σpm(true)\n\n# Define symbolic parameters and Hamiltonian\n@variables Δ g\nH = Δ/2 * σz() + g * (a'()*σm() + a()*σp())\n\n# Define subspace and transform\nP = Subspace(σz() => -1)\nresult = schrieffer_wolff(H, P; order=2)\n\n# Analyze results\nprintln(\"Effective Hamiltonian in ground state subspace:\")\nfor (op, coeff) in collect_terms(result.H_P)\n    println(\"  \", coeff, \"  \", op)\nend\n\n# Extract dispersive shift\nχ = extract_coefficient(result.H_P, a'()*a())\nprintln(\"\\nDispersive shift: χ = \", χ)\nprintln(\"Expected: -g²/Δ\")\n\n","category":"section"},{"location":"tutorial/#N-Level-Atoms","page":"Tutorial","title":"N-Level Atoms","text":"The package supports N-level atomic systems using QuantumAlgebra's nlevel_ops:\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# Create 5-level atom operators: σ[i,j] = |i⟩⟨j|\nσ5 = nlevel_ops(5, :q)\n\n# Define level energies and coupling\nω = [Symbolics.variable(Symbol(\"ω\", i)) for i in 1:5]\n@variables ωc g\n\n# Hamiltonian: 5-level atom + cavity, coupling levels 1↔3\nH = sum(ω[i] * σ5[i,i] for i in 1:5) + \n    ωc * a'()*a() + \n    g * (σ5[1,3] * a'() + σ5[3,1] * a())\n\n# Zero-photon subspace\nP = Subspace(a'()*a() => 0)\n\nresult = schrieffer_wolff(H, P; order=2)\nprintln(\"Effective Hamiltonian:\")\nprintln(result.H_eff)\n\nThe result contains dispersive shifts and AC Stark corrections for all levels.\n\n","category":"section"},{"location":"tutorial/#SU(N)-Systems","page":"Tutorial","title":"SU(N) Systems","text":"For systems described by SU(N) Lie algebras, the package automatically detects and uses the matrix-element method:\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# SU(3) generators (Gell-Mann matrices)\nλ = su_generators(3, :λ)\n\n@variables Δ ω g\n\n# Three-level Lambda system\nH = Δ * λ[8] + ω * λ[7] + g * λ[2]\n\n# Subspace defined by λ₈ eigenvalue\nP = Subspace(λ[8] => 0.5)\n\n# Automatically uses matrix-element method for SU(3)\nresult = schrieffer_wolff(H, P; order=2)\n\n","category":"section"},{"location":"tutorial/#Key-Points","page":"Tutorial","title":"Key Points","text":"Always use QuantumAlgebra.use_σpm(true) for SW transformations with spins\nDefine subspace carefully - this determines what \"diagonal\" means\nUse collect_terms to see simplified coefficients\nThe physics is in the coefficients - extract them with extract_coefficient\nN-level and SU(N) systems are automatically handled with appropriate methods","category":"section"},{"location":"tutorial/#Next-Steps","page":"Tutorial","title":"Next Steps","text":"See Examples for complete physics applications\nSee Theory for mathematical details\nSee API Reference for function documentation","category":"section"}]
}
