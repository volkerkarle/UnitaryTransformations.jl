var documenterSearchIndex = {"docs":
[{"location":"api/#api","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Main-Functions","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api/#Schrieffer-Wolff-Transformation","page":"API Reference","title":"Schrieffer-Wolff Transformation","text":"","category":"section"},{"location":"api/#Subspace-Definition","page":"API Reference","title":"Subspace Definition","text":"","category":"section"},{"location":"api/#Hamiltonian-Decomposition","page":"API Reference","title":"Hamiltonian Decomposition","text":"","category":"section"},{"location":"api/#Generator-Solution","page":"API Reference","title":"Generator Solution","text":"","category":"section"},{"location":"api/#Projection","page":"API Reference","title":"Projection","text":"","category":"section"},{"location":"api/#BCH-Expansion","page":"API Reference","title":"BCH Expansion","text":"","category":"section"},{"location":"api/#Symbolic-Utilities","page":"API Reference","title":"Symbolic Utilities","text":"","category":"section"},{"location":"api/#Coefficient-Manipulation","page":"API Reference","title":"Coefficient Manipulation","text":"","category":"section"},{"location":"api/#Parameter-Conversion","page":"API Reference","title":"Parameter Conversion","text":"","category":"section"},{"location":"api/#Re-exported-from-QuantumAlgebra","page":"API Reference","title":"Re-exported from QuantumAlgebra","text":"The following functions are re-exported for convenience:\n\ncomm(A, B) - Compute commutator A B = AB - BA\nnormal_form(expr) - Normal-order an operator expression\na(), a'() - Bosonic annihilation/creation operators\nÏƒx(), Ïƒy(), Ïƒz() - Pauli matrices\nÏƒp(), Ïƒm() - Raising/lowering operators (when use_Ïƒpm(true))","category":"section"},{"location":"api/#Symbolic-Parameters","page":"API Reference","title":"Symbolic Parameters","text":"Use Symbolics.jl @variables to define symbolic parameters:\n\nusing Symbolics\n@variables Î” g Ï‰  # Define symbolic parameters","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#SWResult","page":"API Reference","title":"SWResult","text":"The schrieffer_wolff function returns a named tuple:\n\nresult = schrieffer_wolff(H, P; order=2)\n\nresult.S      # Generator of the transformation\nresult.H_eff  # Block-diagonal effective Hamiltonian  \nresult.H_P    # H_eff projected onto subspace P","category":"section"},{"location":"api/#Classification-Enums","page":"API Reference","title":"Classification Enums","text":"The package uses classification enums for operator analysis:\n\nDIAGONAL   # Operator preserves the subspace\nRAISING    # Operator raises out of subspace P\nLOWERING   # Operator lowers into subspace P\nMIXED      # Operator has mixed character","category":"section"},{"location":"api/#UnitaryTransformations.schrieffer_wolff","page":"API Reference","title":"UnitaryTransformations.schrieffer_wolff","text":"schrieffer_wolff(H::QuExpr, P::Subspace; order::Int=2)\n\nPerform the Schrieffer-Wolff transformation on Hamiltonian H with respect  to the low-energy subspace P.\n\nThe transformation finds a unitary U = e^S such that H_eff = e^S H e^{-S} is block-diagonal with respect to P and Q = 1-P, up to the specified order in perturbation theory.\n\nArguments\n\nH: The full Hamiltonian to transform\nP: The low-energy subspace definition\norder: Perturbation theory order (default: 2)\nsimplify_generator: Whether to simplify the generator S (default: false). Simplifying S can be very slow at high orders due to GCD computations on complex symbolic fractions. Set to true if you need simplified S.\n\nReturns\n\nNamed tuple (H_eff, S, H_P) where:\nH_eff: The full block-diagonal effective Hamiltonian\nS: The generator of the transformation\nH_P: The effective Hamiltonian projected onto subspace P\n\nExample\n\nusing QuantumAlgebra, UnitaryTransformations, Symbolics\n\n# Jaynes-Cummings in dispersive regime\n@variables Ï‰ Î” g  # Ï‰ = cavity frequency, Î” = qubit splitting, g = coupling strength\n\nH = Ï‰ * a'()*a() + Î”/2 * Ïƒz() + g * (a'()*Ïƒm() + a()*Ïƒp())\n\n# Transform to eliminate qubit-photon coupling\nP = Subspace(Ïƒz() => -1)  # qubit ground state\nresult = schrieffer_wolff(H, P; order=2)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.sw_generator","page":"API Reference","title":"UnitaryTransformations.sw_generator","text":"sw_generator(H::QuExpr, P::Subspace; order::Int=1)\n\nCompute only the generator S for the Schrieffer-Wolff transformation, without computing the full effective Hamiltonian.\n\nThis is useful when you only need S, or want to manually compute the transformation using bch_transform.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.Subspace","page":"API Reference","title":"UnitaryTransformations.Subspace","text":"Subspace(constraints...)\n\nDefine a low-energy subspace P by specifying constraints on operators.\n\nExamples\n\n# Spin-down subspace\nP = Subspace(Ïƒz() => -1)\n\n# Vacuum subspace (zero bosons)\nP = Subspace(a'()*a() => 0)\n\n# Product state: spin-down AND zero bosons\nP = Subspace(Ïƒz() => -1, a'()*a() => 0)\n\n# Indexed systems\nP = Subspace(Ïƒz(:i) => -1)  # All spins down\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitaryTransformations.OperatorConstraint","page":"API Reference","title":"UnitaryTransformations.OperatorConstraint","text":"OperatorConstraint\n\nA single constraint defining a sector: an operator and its eigenvalue in that sector.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitaryTransformations.decompose","page":"API Reference","title":"UnitaryTransformations.decompose","text":"decompose(H::QuExpr, P::Subspace)\n\nDecompose H into diagonal and off-diagonal parts with respect to subspace P.\n\nReturns (Hd, Hod) where:\n\nH_d is the block-diagonal part\nH_od is the off-block-diagonal part\nH = Hd + Hod\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.diagonal_part","page":"API Reference","title":"UnitaryTransformations.diagonal_part","text":"diagonal_part(H::QuExpr, P::Subspace)\n\nExtract the block-diagonal part of H with respect to subspace P. This includes terms that preserve P (PÂ·HÂ·P) and terms that preserve Q (QÂ·HÂ·Q).\n\nNote: Terms classified as MIXED (like Ïƒx when not using Ïƒpm mode) are skipped. For proper handling, ensure Hamiltonians are expressed in the ÏƒÂ± basis.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.off_diagonal_part","page":"API Reference","title":"UnitaryTransformations.off_diagonal_part","text":"off_diagonal_part(H::QuExpr, P::Subspace)\n\nExtract the off-block-diagonal part of H with respect to subspace P. This includes terms that couple P to Q (PÂ·HÂ·Q + QÂ·HÂ·P).\n\nNote: Terms classified as MIXED (like Ïƒx when not using Ïƒpm mode) are skipped. For proper handling, ensure Hamiltonians are expressed in the ÏƒÂ± basis.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.is_diagonal","page":"API Reference","title":"UnitaryTransformations.is_diagonal","text":"is_diagonal(expr::QuExpr, P::Subspace)\n\nCheck if an expression is purely block-diagonal with respect to subspace P.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.is_off_diagonal","page":"API Reference","title":"UnitaryTransformations.is_off_diagonal","text":"is_off_diagonal(expr::QuExpr, P::Subspace)\n\nCheck if an expression is purely off-block-diagonal with respect to subspace P.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.solve_for_generator","page":"API Reference","title":"UnitaryTransformations.solve_for_generator","text":"solve_for_generator(H_d::QuExpr, V_od::QuExpr, P::Subspace)\n\nSolve [S, Hd] = -Vod for the generator S.\n\nThis is the core equation in Schrieffer-Wolff: we need to find S such that the commutator with the diagonal part cancels the off-diagonal perturbation.\n\nFor each term in Vod, if [Hd, O] = ÎµÂ·O, then the corresponding term in S is O/Îµ. (Note: [S, Hd] = [O/Îµ, Hd] = (1/Îµ)[O, Hd] = -(1/Îµ)Â·ÎµÂ·O = -O matches -Vod)\n\nUses Symbolics.jl for proper symbolic division, allowing denominators like (Î” - Ï‰).\n\nArguments\n\nH_d: The diagonal (unperturbed) Hamiltonian\nV_od: The off-diagonal perturbation to be eliminated\nP: The subspace defining the block structure\n\nReturns\n\nS: The generator of the transformation (anti-Hermitian)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.compute_energy_denominator","page":"API Reference","title":"UnitaryTransformations.compute_energy_denominator","text":"compute_energy_denominator(H_d::QuExpr, term::QuTerm, P::Subspace)\n\nCompute the energy denominator for a given off-diagonal term.\n\nFor an off-diagonal operator O, if [Hd, O] = ÎµÂ·O, then the energy denominator is Îµ. This is computed by evaluating [Hd, O] and extracting the coefficient.\n\nReturns the energy denominator as a Symbolics Num expression.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.project_to_subspace","page":"API Reference","title":"UnitaryTransformations.project_to_subspace","text":"project_to_subspace(H::QuExpr, P::Subspace)\n\nProject an operator onto the subspace P.\n\nThis replaces diagonal operators by their eigenvalues in P:\n\nÏƒz â†’ eigenvalue (e.g., -1 for spin down)\nÏƒâºÏƒâ» â†’ 0 for spin down, 1 for spin up\naâ€ a â†’ eigenvalue (e.g., 0 for vacuum)\n\nAnd removes any remaining off-diagonal terms.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.bch_transform","page":"API Reference","title":"UnitaryTransformations.bch_transform","text":"bch_transform(S::QuExpr, A::QuExpr; order::Int=4)\n\nCompute e^S A e^{-S} using the BCH formula to the specified order.\n\nThis computes the adjoint action of e^S on an operator A:     e^S A e^{-S} = A + [S,A] + (1/2!)[S,[S,A]] + (1/3!)[S,[S,[S,A]]] + ...\n\nArguments\n\nS: The generator (typically anti-Hermitian: Sâ€  = -S)\nA: The operator to transform (e.g., a Hamiltonian)\norder: Number of nested commutators to include (default: 4)\n\nExample\n\nusing QuantumAlgebra, UnitaryTransformations, Symbolics\n@variables g Î”\n\n# Generator from SW transformation\nS = (g/Î”) * (a'()*Ïƒm() - a()*Ïƒp())\n\n# Transform the Hamiltonian\nH = Î”/2 * Ïƒz() + g * (a'()*Ïƒm() + a()*Ïƒp())\nH_transformed = bch_transform(S, H; order=2)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.commutator_series","page":"API Reference","title":"UnitaryTransformations.commutator_series","text":"commutator_series(S::QuExpr, H::QuExpr, order::Int)\n\nCompute the BCH expansion of e^S H e^{-S} to the given order.\n\ne^S H e^{-S} = Î£â‚™ (1/n!) [S, [S, [..., [S, H]...]]]  (n nested commutators)\n\nThe expansion is truncated at order nested commutators.\n\nArguments\n\nS: The generator of the unitary transformation (anti-Hermitian: Sâ€  = -S)\nH: The operator to transform\norder: Maximum number of nested commutators to include\n\nReturns\n\nThe transformed operator as a QuExpr\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.nested_commutator","page":"API Reference","title":"UnitaryTransformations.nested_commutator","text":"nested_commutator(S::QuExpr, H::QuExpr, n::Int)\n\nCompute the n-fold nested commutator [S, [S, [..., [S, H]...]]] with S appearing n times.\n\nn=0 returns H\nn=1 returns [S, H]\nn=2 returns [S, [S, H]]\netc.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.simplify_coefficients","page":"API Reference","title":"UnitaryTransformations.simplify_coefficients","text":"simplify_coefficients(expr::QuExpr)\n\nSimplify all Symbolics coefficients in a QuExpr. Returns a new QuExpr with simplified coefficients.\n\nUses simplify_fractions which is much faster than full simplify for the rational expressions that arise in Schrieffer-Wolff.\n\nNote: Parallelization was attempted but SymbolicUtils/Symbolics.jl has thread-safety issues that cause race conditions during simplification. The serial version is used for correctness.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.substitute_values","page":"API Reference","title":"UnitaryTransformations.substitute_values","text":"substitute_values(expr::QuExpr, values::Dict{Symbol, Number})\n\nSubstitute numerical values for symbolic parameters in a QuExpr.\n\nArguments\n\nexpr: A QuExpr with symbolic coefficients\nvalues: Dict mapping parameter symbols to numerical values\n\nExample\n\nH_P = result.H_P\nvalues = Dict(:g => 0.1, :Î” => 1.0)\nH_numeric = substitute_values(H_P, values)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.extract_coefficient","page":"API Reference","title":"UnitaryTransformations.extract_coefficient","text":"extract_coefficient(expr::QuExpr, target_ops::QuExpr)\n\nExtract the coefficient of a specific operator structure from a QuExpr.\n\nArguments\n\nexpr: The full QuExpr to search\ntarget_ops: The operator structure to match (e.g., a'()*a())\n\nReturns\n\nThe coefficient (Num or Number) if found, nothing otherwise\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.collect_terms","page":"API Reference","title":"UnitaryTransformations.collect_terms","text":"collect_terms(expr::QuExpr)\n\nCollect and display all terms in a QuExpr with their simplified coefficients. Returns a vector of (operatorstring, simplifiedcoefficient) pairs.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.param_to_symbolic","page":"API Reference","title":"UnitaryTransformations.param_to_symbolic","text":"param_to_symbolic(p::Param)\n\nConvert a QuantumAlgebra Param to a Symbolics variable. Caches variables to ensure the same param always maps to the same variable.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.clear_param_cache!","page":"API Reference","title":"UnitaryTransformations.clear_param_cache!","text":"clear_param_cache!()\n\nClear the parameter to Symbolics variable cache. Useful when starting a new calculation with fresh variables.\n\n\n\n\n\n","category":"function"},{"location":"examples/#examples","page":"Examples","title":"Examples","text":"This page presents complete physics examples demonstrating the package capabilities.","category":"section"},{"location":"examples/#Jaynes-Cummings:-Dispersive-Regime","page":"Examples","title":"Jaynes-Cummings: Dispersive Regime","text":"The Jaynes-Cummings model describes a two-level atom coupled to a single cavity mode:\n\nH = omega_c a^dagger a + fracomega_q2sigma_z + g(a^daggersigma^- + asigma^+)\n\nIn the dispersive regime (Delta = omega_q - omega_c gg g), the Schrieffer-Wolff transformation yields an effective Hamiltonian with a state-dependent frequency shift.\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\nQuantumAlgebra.use_Ïƒpm(true)\nUnitaryTransformations.clear_param_cache!()\n\n# Define symbolic parameters\n@variables Î” g  # Î” = detuning Ï‰_q - Ï‰_c, g = coupling\n\n# Hamiltonian (in frame rotating at Ï‰_c)\nH = Î”/2 * Ïƒz() + g * (a'()*Ïƒm() + a()*Ïƒp())\n\n# Ground state subspace\nP = Subspace(Ïƒz() => -1)\n\n# Transform\nresult = schrieffer_wolff(H, P; order=2)\n\n# Results\nprintln(\"Effective Hamiltonian:\")\nfor (op, coeff) in collect_terms(result.H_eff)\n    println(\"  \", coeff, \"  \", op)\nend","category":"section"},{"location":"examples/#Physical-Interpretation","page":"Examples","title":"Physical Interpretation","text":"The effective Hamiltonian contains:\n\nDispersive shift: chi = g^2Delta \nCavity frequency shifts by pmchi depending on qubit state\nUsed for qubit readout in circuit QED\nAC Stark shift: Qubit frequency shifts with photon number\nomega_q to omega_q + 2chi langle a^dagger a rangle","category":"section"},{"location":"examples/#Numerical-Verification","page":"Examples","title":"Numerical Verification","text":"# Compare with expected value\nÏ‡ = extract_coefficient(result.H_P, a'()*a())\nprintln(\"Computed Ï‡ = \", Ï‡)\nprintln(\"Expected:  -gÂ²/Î”\")\n\n# Substitute values\nÏ‡_num = substitute_values(result.H_P, Dict(:g => 0.1, :Î” => 1.0))\nprintln(\"Ï‡(g=0.1, Î”=1) = -0.01  # matches -gÂ²/Î”!\")\n\n","category":"section"},{"location":"examples/#Two-Level-System-with-Transverse-Field","page":"Examples","title":"Two-Level System with Transverse Field","text":"A qubit in longitudinal and transverse magnetic fields:\n\nH = fracDelta2sigma_z + varepsilonsigma_x\n\nThis is a textbook quantum mechanics problem with exact solution, making it perfect for verification.\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\nQuantumAlgebra.use_Ïƒpm(true)\nUnitaryTransformations.clear_param_cache!()\n\n# Define symbolic parameters\n@variables Î” Îµ  # Î” = longitudinal field (energy splitting), Îµ = transverse field (perturbation)\n\n# Hamiltonian: Ïƒx = Ïƒâº + Ïƒâ»\nH = Î”/2 * Ïƒz() + Îµ * (Ïƒp() + Ïƒm())\n\n# Ground state subspace\nP = Subspace(Ïƒz() => -1)\n\n# Transform\nresult = schrieffer_wolff(H, P; order=2)\n\nprintln(\"Projected Hamiltonian H_P:\")\nfor (op, coeff) in collect_terms(result.H_P)\n    println(\"  \", coeff, \"  \", op)\nend","category":"section"},{"location":"examples/#Comparison-with-Exact-Solution","page":"Examples","title":"Comparison with Exact Solution","text":"The exact eigenvalues are:\n\nE_pm = pmsqrtDelta^24 + varepsilon^2\n\nThe SW result for the ground state energy is:\n\nE_g = -fracDelta2 - fracvarepsilon^2Delta + O(varepsilon^4)\n\n# Numerical comparison\nfor Îµ_val in [0.01, 0.05, 0.1, 0.2]\n    Î”_val = 1.0\n    E_exact = -sqrt(Î”_val^2/4 + Îµ_val^2)\n    E_SW = -Î”_val/2 - Îµ_val^2/Î”_val\n    error = 100 * abs(E_exact - E_SW) / abs(E_exact)\n    println(\"Îµ/Î” = $Îµ_val: error = $(round(error, digits=4))%\")\nend\n\nOutput:\n\nÎµ/Î” = 0.01: error = 0.0%\nÎµ/Î” = 0.05: error = 0.0012%\nÎµ/Î” = 0.1: error = 0.0192%\nÎµ/Î” = 0.2: error = 0.2755%\n\nThe perturbative result is excellent when varepsilon ll Delta!\n\n","category":"section"},{"location":"examples/#Rabi-Model:-Bloch-Siegert-Shift","page":"Examples","title":"Rabi Model: Bloch-Siegert Shift","text":"The full Rabi model includes counter-rotating terms that are neglected in the rotating-wave approximation:\n\nH = omega a^dagger a + fracDelta2sigma_z + g(sigma^+ + sigma^-)(a + a^dagger)\n\nThe counter-rotating terms (a^daggersigma^+ and asigma^-) lead to the Bloch-Siegert shift.\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\nQuantumAlgebra.use_Ïƒpm(true)\nUnitaryTransformations.clear_param_cache!()\n\n# Define symbolic parameters\n@variables Ï‰ Î” g  # Ï‰ = oscillator frequency, Î” = qubit splitting, g = coupling\n\n# Full Rabi Hamiltonian (no RWA)\nH_rabi = Ï‰ * a'()*a() + Î”/2 * Ïƒz() + g * (Ïƒp() + Ïƒm()) * (a() + a'())\n\n# For comparison: Jaynes-Cummings (with RWA)\nH_jc = Ï‰ * a'()*a() + Î”/2 * Ïƒz() + g * (a'()*Ïƒm() + a()*Ïƒp())\n\nP = Subspace(Ïƒz() => -1)\n\nresult_rabi = schrieffer_wolff(H_rabi, P; order=2)\nresult_jc = schrieffer_wolff(H_jc, P; order=2)\n\nprintln(\"Full Rabi model produces additional terms:\")\nprintln(\"  - Squeezing terms: aÂ², (aâ€ )Â²\")\nprintln(\"  - Modified dispersive shift\")","category":"section"},{"location":"examples/#Bloch-Siegert-Correction","page":"Examples","title":"Bloch-Siegert Correction","text":"The counter-rotating terms contribute an additional frequency shift:\n\nchi_BS approx fracg^2Delta + 2omega\n\nThis is typically small (âˆ¼1% of the JC dispersive shift) but measurable in precision experiments.\n\n","category":"section"},{"location":"examples/#Running-the-Examples","page":"Examples","title":"Running the Examples","text":"The complete example files are in the examples/ directory:\n\ncd UnitaryTransformations.jl\njulia --project examples/jaynes_cummings_dispersive.jl\njulia --project examples/two_level_system.jl\njulia --project examples/rabi_bloch_siegert.jl\n\nEach example includes detailed physical interpretation and numerical verification.","category":"section"},{"location":"#UnitaryTransformations.jl","page":"Home","title":"UnitaryTransformations.jl","text":"A Julia package for performing symbolic Schrieffer-Wolff transformations on quantum Hamiltonians.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"The Schrieffer-Wolff transformation is a powerful perturbative technique for deriving effective low-energy Hamiltonians. Given a quantum system with well-separated energy scales, it systematically eliminates high-energy degrees of freedom while capturing their effects through renormalized parameters.\n\nThis package provides:\n\nSymbolic computation of effective Hamiltonians\nAutomatic commutator algebra for bosons, fermions, and spins  \nProper energy denominators like gÂ²/Î” using Symbolics.jl\nProjection onto chosen low-energy subspaces","category":"section"},{"location":"#When-to-Use-Schrieffer-Wolff","page":"Home","title":"When to Use Schrieffer-Wolff","text":"The transformation is ideal when:\n\nYour Hamiltonian has a small perturbation coupling different energy sectors\nYou want to work in a reduced subspace (e.g., ground state manifold)\nYou need analytical expressions for effective parameters\n\nCommon applications include:\n\nDispersive readout in circuit QED\nExchange interactions from virtual hopping (t-J model from Hubbard)\nEffective spin models from electronic systems","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/volkerkarle/UnitaryTransformations.jl\")\n\nThe package will automatically install its dependencies:\n\nQuantumAlgebra.jl - Symbolic quantum operator algebra\nSymbolics.jl - Computer algebra system","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# Use ÏƒÂ± basis (recommended for SW transformations)\nQuantumAlgebra.use_Ïƒpm(true)\n\n# Define symbolic parameters\n@variables Î” g  # Î” = energy splitting, g = coupling strength\n\n# Jaynes-Cummings Hamiltonian\nH = Î”/2 * Ïƒz() + g * (a'()*Ïƒm() + a()*Ïƒp())\n\n# Define the low-energy subspace (qubit in ground state)\nP = Subspace(Ïƒz() => -1)\n\n# Perform Schrieffer-Wolff transformation\nresult = schrieffer_wolff(H, P; order=2)\n\n# The effective Hamiltonian in the ground state subspace\nprintln(result.H_P)\n# Output: -0.5Î” + (-(g^2))/Î” aâ€ a","category":"section"},{"location":"#Package-Structure","page":"Home","title":"Package Structure","text":"UnitaryTransformations.jl/\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ UnitaryTransformations.jl  # Main module\nâ”‚   â”œâ”€â”€ subspace.jl                # Subspace type definition\nâ”‚   â”œâ”€â”€ decompose.jl               # H â†’ H_d + V_od decomposition\nâ”‚   â”œâ”€â”€ commutator_series.jl       # BCH expansion\nâ”‚   â”œâ”€â”€ inverse_liouvillian.jl     # Solve [S, H_d] = -V_od\nâ”‚   â”œâ”€â”€ schrieffer_wolff.jl        # Main SW algorithm\nâ”‚   â””â”€â”€ symbolic_utils.jl          # Simplification utilities\nâ”œâ”€â”€ examples/\nâ”‚   â”œâ”€â”€ jaynes_cummings_dispersive.jl\nâ”‚   â”œâ”€â”€ two_level_system.jl\nâ”‚   â””â”€â”€ rabi_bloch_siegert.jl\nâ””â”€â”€ test/\n    â””â”€â”€ runtests.jl","category":"section"},{"location":"#Next-Steps","page":"Home","title":"Next Steps","text":"See the Tutorial for a step-by-step guide\nCheck the Examples for physics applications\nBrowse the API Reference for function documentation","category":"section"},{"location":"tutorial/#tutorial","page":"Tutorial","title":"Tutorial","text":"This tutorial walks through the Schrieffer-Wolff transformation step by step.","category":"section"},{"location":"tutorial/#The-Problem","page":"Tutorial","title":"The Problem","text":"Consider a quantum system with Hamiltonian:\n\nH = H_0 + V\n\nwhere H_0 has well-separated energy eigenspaces and V is a perturbation that couples them. We want to find an effective Hamiltonian H_texteff that:\n\nActs only within a chosen low-energy subspace P\nCaptures the effects of V to a given order in perturbation theory","category":"section"},{"location":"tutorial/#Step-1:-Set-Up-the-System","page":"Tutorial","title":"Step 1: Set Up the System","text":"Let's work with a concrete example: a two-level system (qubit) coupled to a harmonic oscillator.\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# Use ÏƒÂ± basis - this is important for SW to work correctly!\nQuantumAlgebra.use_Ïƒpm(true)\n\n# Define symbolic parameters\n@variables Î” g  # Î” = qubit-oscillator detuning, g = coupling strength\n\n# Jaynes-Cummings Hamiltonian (in rotating frame)\nH = Î”/2 * Ïƒz() + g * (a'()*Ïƒm() + a()*Ïƒp())\n\nThe Hamiltonian describes:\n\nA qubit with splitting Î” (the Ïƒ_z term)\nCoupling to an oscillator mode (the a^dagger Ïƒ^- and a Ïƒ^+ terms)","category":"section"},{"location":"tutorial/#Step-2:-Define-the-Subspace","page":"Tutorial","title":"Step 2: Define the Subspace","text":"We need to specify which states belong to the low-energy subspace P. For this example, we choose the qubit ground state:\n\n# P = states where Ïƒz = -1 (qubit in ground state |gâŸ©)\nP = Subspace(Ïƒz() => -1)\n\nThe Subspace type specifies expectation values of operators in the subspace. Here, we say that in subspace P, the operator Ïƒ_z has eigenvalue -1.","category":"section"},{"location":"tutorial/#Step-3:-Decompose-the-Hamiltonian","page":"Tutorial","title":"Step 3: Decompose the Hamiltonian","text":"The SW transformation requires splitting H into diagonal and off-diagonal parts with respect to P:\n\nH_d, V_od = decompose(H, P)\n\nprintln(\"Diagonal:     \", H_d)\nprintln(\"Off-diagonal: \", V_od)\n\nOutput:\n\nDiagonal:     -0.5Î” + Î” ÏƒâºÏƒâ»\nOff-diagonal: g aâ€ Ïƒâ» + g a Ïƒâº\n\nDiagonal (H_d): Operators that don't change the subspace (like Ïƒ^+Ïƒ^-, a^dagger a)\nOff-diagonal (V_od): Operators that connect P and Q subspaces (like Ïƒ^+, Ïƒ^-)","category":"section"},{"location":"tutorial/#Step-4:-Perform-the-Transformation","page":"Tutorial","title":"Step 4: Perform the Transformation","text":"Now we apply the Schrieffer-Wolff transformation:\n\nresult = schrieffer_wolff(H, P; order=2)\n\nThis returns a named tuple with:\n\nresult.S - The generator of the unitary transformation\nresult.H_eff - The block-diagonal effective Hamiltonian\nresult.H_P - The effective Hamiltonian projected onto subspace P","category":"section"},{"location":"tutorial/#Step-5:-Analyze-the-Results","page":"Tutorial","title":"Step 5: Analyze the Results","text":"","category":"section"},{"location":"tutorial/#The-Generator","page":"Tutorial","title":"The Generator","text":"println(\"Generator S = \", result.S)\n# S = (g/Î”) aâ€ Ïƒâ» + (-g/Î”) a Ïƒâº\n\nThe generator S is anti-Hermitian (S^dagger = -S) and satisfies the fundamental equation:\n\nS H_d = -V_od","category":"section"},{"location":"tutorial/#The-Effective-Hamiltonian","page":"Tutorial","title":"The Effective Hamiltonian","text":"# Collect and display all terms with simplified coefficients\nterms = collect_terms(result.H_eff)\nfor (op, coeff) in terms\n    println(\"  \", coeff, \"  \", op)\nend\n\nOutput:\n\n  -0.5Î”        ðŸ™\n  -(gÂ²)/Î”      aâ€ a\n  Î” + (gÂ²)/Î”   ÏƒâºÏƒâ»\n  ...","category":"section"},{"location":"tutorial/#The-Projected-Hamiltonian","page":"Tutorial","title":"The Projected Hamiltonian","text":"For many applications, we only care about the subspace P:\n\nprintln(\"H_P = \", result.H_P)\n# H_P = -0.5Î” + (-(gÂ²)/Î”) aâ€ a\n\nThis is the dispersive Hamiltonian: the cavity frequency is shifted by -g^2Delta when the qubit is in the ground state!","category":"section"},{"location":"tutorial/#Step-6:-Extract-Physical-Parameters","page":"Tutorial","title":"Step 6: Extract Physical Parameters","text":"Use the utility functions to extract specific coefficients:\n\n# Get the dispersive shift (coefficient of aâ€ a)\nÏ‡ = extract_coefficient(result.H_P, a'()*a())\nprintln(\"Dispersive shift Ï‡ = \", Ï‡)\n# Output: -(gÂ²)/Î”","category":"section"},{"location":"tutorial/#Step-7:-Numerical-Evaluation","page":"Tutorial","title":"Step 7: Numerical Evaluation","text":"Substitute numerical values to get concrete numbers:\n\nH_numeric = substitute_values(result.H_P, Dict(:g => 0.1, :Î” => 1.0))\nprintln(\"H_P with g=0.1, Î”=1.0: \", H_numeric)","category":"section"},{"location":"tutorial/#Complete-Example","page":"Tutorial","title":"Complete Example","text":"Here's the full code:\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# Setup\nQuantumAlgebra.use_Ïƒpm(true)\n\n# Define symbolic parameters and Hamiltonian\n@variables Î” g\nH = Î”/2 * Ïƒz() + g * (a'()*Ïƒm() + a()*Ïƒp())\n\n# Define subspace and transform\nP = Subspace(Ïƒz() => -1)\nresult = schrieffer_wolff(H, P; order=2)\n\n# Analyze results\nprintln(\"Effective Hamiltonian in ground state subspace:\")\nfor (op, coeff) in collect_terms(result.H_P)\n    println(\"  \", coeff, \"  \", op)\nend\n\n# Extract dispersive shift\nÏ‡ = extract_coefficient(result.H_P, a'()*a())\nprintln(\"\\nDispersive shift: Ï‡ = \", Ï‡)\nprintln(\"Expected: -gÂ²/Î” âœ“\")","category":"section"},{"location":"tutorial/#Key-Points","page":"Tutorial","title":"Key Points","text":"Always use QuantumAlgebra.use_Ïƒpm(true) for SW transformations with spins\nDefine subspace carefully - this determines what \"diagonal\" means\nUse collect_terms to see simplified coefficients\nThe physics is in the coefficients - extract them with extract_coefficient","category":"section"}]
}
