var documenterSearchIndex = {"docs":
[{"location":"api/#api","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Main-Functions","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api/#Schrieffer-Wolff-Transformation","page":"API Reference","title":"Schrieffer-Wolff Transformation","text":"","category":"section"},{"location":"api/#Magnus-Expansion-(Floquet-Systems)","page":"API Reference","title":"Magnus Expansion (Floquet Systems)","text":"","category":"section"},{"location":"api/#Subspace-Definition","page":"API Reference","title":"Subspace Definition","text":"","category":"section"},{"location":"api/#Hamiltonian-Decomposition","page":"API Reference","title":"Hamiltonian Decomposition","text":"","category":"section"},{"location":"api/#Generator-Solution","page":"API Reference","title":"Generator Solution","text":"The core operation in Schrieffer-Wolff is solving S H_d = -V_od for the generator S.","category":"section"},{"location":"api/#Main-Function","page":"API Reference","title":"Main Function","text":"","category":"section"},{"location":"api/#Method-Specific-Functions","page":"API Reference","title":"Method-Specific Functions","text":"Two methods are available, automatically selected based on the operator types:\n\nThe eigenoperator method works when H_d O = varepsilon cdot O (TLS, bosons, N-level transitions).\n\nThe Lie algebra method works for SU(N) systems by converting to the Cartan-Weyl basis where generators become eigenoperators.","category":"section"},{"location":"api/#Supporting-Functions","page":"API Reference","title":"Supporting Functions","text":"","category":"section"},{"location":"api/#Projection","page":"API Reference","title":"Projection","text":"","category":"section"},{"location":"api/#BCH-Expansion","page":"API Reference","title":"BCH Expansion","text":"The Baker-Campbell-Hausdorff expansion is used to compute e^S H e^-S.\n\n","category":"section"},{"location":"api/#Symbolic-Utilities","page":"API Reference","title":"Symbolic Utilities","text":"","category":"section"},{"location":"api/#Coefficient-Manipulation","page":"API Reference","title":"Coefficient Manipulation","text":"","category":"section"},{"location":"api/#Simplification-Modes","page":"API Reference","title":"Simplification Modes","text":"The simplify_coefficients function supports several modes for different speed/quality trade-offs:\n\nMode Description Speed\n:none No simplification Fastest\n:fast Expansion only (flattens nested expressions) Fast (default)\n:standard Full algebraic simplification with expansion Moderate\n:fractions Simplify rational expressions with GCD Slow\n:aggressive Maximum simplification Slowest\n\n# For exploration and debugging (fastest)\nresult = schrieffer_wolff(H, P; order=4, simplify_mode=:none)\n\n# For final results (default, good balance)\nresult = schrieffer_wolff(H, P; order=4, simplify_mode=:fast)\n\n# For publication-ready expressions\nH_simplified = simplify_coefficients(result.H_P; mode=:standard)","category":"section"},{"location":"api/#LaTeX-Output","page":"API Reference","title":"LaTeX Output","text":"","category":"section"},{"location":"api/#Parameter-Conversion","page":"API Reference","title":"Parameter Conversion","text":"Functions for converting between QuantumAlgebra's Param and Symbolics.jl variables:\n\n","category":"section"},{"location":"api/#Re-exported-from-QuantumAlgebra","page":"API Reference","title":"Re-exported from QuantumAlgebra","text":"The following functions are re-exported for convenience:\n\ncomm(A, B) - Compute commutator A B = AB - BA\nnormal_form(expr) - Normal-order an operator expression\na(), a'() - Bosonic annihilation/creation operators\nσx(), σy(), σz() - Pauli matrices\nσp(), σm() - Raising/lowering operators (when use_σpm(true))\nnlevel_ops(N, name) - N-level transition operators iranglelangle j\nsu_generators(N, name) - SU(N) generators (generalized Gell-Mann matrices)\n\n","category":"section"},{"location":"api/#Symbolic-Parameters","page":"API Reference","title":"Symbolic Parameters","text":"Use Symbolics.jl @variables to define symbolic parameters:\n\nusing Symbolics\n@variables Δ g ω  # Define symbolic parameters\n\nFor N-level systems with indexed parameters:\n\n# Create ω₁, ω₂, ..., ωₙ\nω = [Symbolics.variable(Symbol(\"ω\", i)) for i in 1:N]\n\n","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#SWResult","page":"API Reference","title":"SWResult","text":"The schrieffer_wolff function returns a named tuple:\n\nresult = schrieffer_wolff(H, P; order=2)\n\nresult.S      # Generator of the transformation\nresult.H_eff  # Block-diagonal effective Hamiltonian  \nresult.H_P    # H_eff projected onto subspace P","category":"section"},{"location":"api/#Subspace","page":"API Reference","title":"Subspace","text":"# Single constraint\nP = Subspace(σz() => -1)\n\n# Multiple constraints\nP = Subspace(σz() => -1, a'()*a() => 0)\n\n# N-level constraint\nP = Subspace(a'()*a() => 0)  # zero photons","category":"section"},{"location":"api/#Classification-Enums","page":"API Reference","title":"Classification Enums","text":"The package uses classification enums for operator analysis:\n\nDIAGONAL   # Operator preserves the subspace\nRAISING    # Operator raises out of subspace P\nLOWERING   # Operator lowers into subspace P\nMIXED      # Operator has mixed character\n\n","category":"section"},{"location":"api/#Performance-Tips","page":"API Reference","title":"Performance Tips","text":"","category":"section"},{"location":"api/#Parallel-Computation","page":"API Reference","title":"Parallel Computation","text":"For high-order SW transformations, enable multi-threading:\n\n# Start Julia with 4 threads\njulia -t 4\n\n# Enable parallel BCH term computation\nresult = schrieffer_wolff(H, P; order=5, parallel=true)","category":"section"},{"location":"api/#Benchmarks-(Jaynes-Cummings-model,-4-threads)","page":"API Reference","title":"Benchmarks (Jaynes-Cummings model, 4 threads)","text":"Order simplify_mode=:none simplify_mode=:fast\n4 0.4 s 0.6 s\n5 1.7 s 1.7 s\n6 50 s 80 s","category":"section"},{"location":"api/#Recommended-Workflow","page":"API Reference","title":"Recommended Workflow","text":"Explore with simplify_mode=:none for speed\nVerify with simplify_mode=:fast (default)\nSimplify for publication with simplify_coefficients(expr; mode=:standard)\n\n","category":"section"},{"location":"api/#Internal-Functions","page":"API Reference","title":"Internal Functions","text":"These functions are not exported but may be useful for advanced users:","category":"section"},{"location":"api/#Lie-Algebra-Support","page":"API Reference","title":"Lie Algebra Support","text":"# Get generators for detected Lie algebra\nget_generators_for_lie_system(lie_info::NamedTuple)\n\n# Convert between bases\ngellmann_to_cartan_weyl(V_od, N, algebra_id)\ncartan_weyl_to_gellmann(transitions, N, generators)","category":"section"},{"location":"api/#Operator-Classification","page":"API Reference","title":"Operator Classification","text":"# Classify a single term\nclassify_term(term::QuTerm, coeff, constraints)\n\n# Check if operator contains only specific types\nhas_only_bosons(term::QuTerm)\nhas_only_tls(term::QuTerm)","category":"section"},{"location":"api/#UnitaryTransformations.schrieffer_wolff","page":"API Reference","title":"UnitaryTransformations.schrieffer_wolff","text":"schrieffer_wolff(H::QuExpr, P::Subspace; order::Int=2)\n\nPerform the Schrieffer-Wolff transformation on Hamiltonian H with respect  to the low-energy subspace P.\n\nThe transformation finds a unitary U = e^S such that H_eff = e^S H e^{-S} is block-diagonal with respect to P and Q = 1-P, up to the specified order in perturbation theory.\n\nArguments\n\nH: The full Hamiltonian to transform\nP: The low-energy subspace definition\norder: Perturbation theory order in the coupling strength (default: 2).\norder=2: Standard SW, captures g² corrections (dispersive shifts)\norder=4: Includes g⁴ corrections (Kerr nonlinearity, Bloch-Siegert, etc.)\nsimplify_generator: Whether to simplify the generator S (default: false). Simplifying S can be slow at high orders. Set to true if you need simplified S.\nsimplify_mode: Simplification mode for final output (default: :fast).\n:none - No simplification (fastest)\n:fast - Expansion only (default, very fast, recommended)\n:standard - Basic algebraic simplification with expansion\n:fractions - Simplify fractions with GCD (slow on complex expressions)\n:aggressive - Full simplification (slowest)\ndiagonal_only: If true, only compute H_eff (skip computing higher-order generators). This is much faster for high orders when you only need the effective Hamiltonian. Note: This uses a simplified algorithm that only uses S₁.\nparallel: If true, use multi-threading for orders > 3 (default: false). Requires Julia to be started with multiple threads (e.g., julia -t 4). For best performance, use 4-8 threads; more threads can cause lock contention. Parallelization is most beneficial for orders 4-6 with complex Hamiltonians.\n\nReturns\n\nNamed tuple (H_eff, S, H_P) where:\nH_eff: The full block-diagonal effective Hamiltonian\nS: The generator of the transformation (S = S₁ + S₂ + ... where Sₙ is O(gⁿ))     Note: If diagonal_only=true, S contains only S₁.\nH_P: The effective Hamiltonian projected onto subspace P\n\nAlgorithm\n\nThe SW transformation uses S = S₁ + S₂ + S₃ + ... where each Sₙ is order gⁿ. At each order, the off-diagonal terms from the BCH expansion determine Sₙ, and the diagonal terms contribute to H_eff.\n\nKey commutator rules (D=diagonal, O=off-diagonal):\n\n[O, O] → D\n[O, D] → O  \n[D, D] → D\n\nExample\n\nusing QuantumAlgebra, UnitaryTransformations, Symbolics\n\n# Jaynes-Cummings in dispersive regime\n@variables ω Δ g  # ω = cavity frequency, Δ = qubit splitting, g = coupling strength\n\nH = ω * a'()*a() + Δ/2 * σz() + g * (a'()*σm() + a()*σp())\n\n# Transform to eliminate qubit-photon coupling\nP = Subspace(σz() => -1)  # qubit ground state\nresult = schrieffer_wolff(H, P; order=2)\n\n# For 4th order corrections (Kerr effect, etc.) - parallel computation\nresult4 = schrieffer_wolff(H, P; order=4, parallel=true)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.sw_generator","page":"API Reference","title":"UnitaryTransformations.sw_generator","text":"sw_generator(H::QuExpr, P::Subspace; order::Int=1)\n\nCompute only the generator S for the Schrieffer-Wolff transformation, without computing the full effective Hamiltonian.\n\nThis is useful when you only need S, or want to manually compute the transformation using bch_transform.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.magnus_expansion","page":"API Reference","title":"UnitaryTransformations.magnus_expansion","text":"magnus_expansion(H::FourierHamiltonian; order::Int=2, check_hermitian::Bool=true)\n\nCompute the Magnus expansion for a periodically driven system to arbitrary order.\n\nArguments\n\nH: A FourierHamiltonian representing H(t) = Σₙ Hₙ e^{inωt}\norder: Maximum order of the expansion (default: 2, no upper limit)\ncheck_hermitian: Whether to verify H is Hermitian (default: true)\n\nReturns\n\nA MagnusResult containing:\n\nH_eff: The effective time-independent Hamiltonian\norders: Dict mapping order k to Ωₖ\nΩ1, Ω2, ...: Direct access to individual contributions\n\nExample\n\nusing QuantumAlgebra, UnitaryTransformations, Symbolics\nQuantumAlgebra.use_σpm(true)\n\n@variables Δ Ω ω\nmodes = Dict(0 => Δ/2*σz(), 1 => Ω/2*σp(), -1 => Ω/2*σm())\nresult = magnus_expansion(modes, ω; order=5)\nprintln(\"Order 5: \", result.Ω5)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.FourierHamiltonian","page":"API Reference","title":"UnitaryTransformations.FourierHamiltonian","text":"FourierHamiltonian\n\nRepresents a time-periodic Hamiltonian in Fourier representation:     H(t) = Σₙ Hₙ e^{inωt}\n\nThe modes are stored as a Dict{Int, QuExpr} mapping Fourier index n to operator Hₙ.\n\nFor Hermiticity, we require H₋ₙ = Hₙ†.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitaryTransformations.check_hermiticity","page":"API Reference","title":"UnitaryTransformations.check_hermiticity","text":"check_hermiticity(H::FourierHamiltonian; warn_only::Bool=false)\n\nCheck that the Fourier Hamiltonian satisfies H₋ₙ = Hₙ† for all modes.\n\nReturns true if Hermitian, throws an error otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.MagnusResult","page":"API Reference","title":"UnitaryTransformations.MagnusResult","text":"MagnusResult\n\nResult type for Magnus expansion containing H_eff and individual order contributions.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitaryTransformations.Subspace","page":"API Reference","title":"UnitaryTransformations.Subspace","text":"Subspace(constraints...)\n\nDefine a low-energy subspace P by specifying constraints on operators.\n\nExamples\n\n# Spin-down subspace\nP = Subspace(σz() => -1)\n\n# Vacuum subspace (zero bosons)\nP = Subspace(a'()*a() => 0)\n\n# Product state: spin-down AND zero bosons\nP = Subspace(σz() => -1, a'()*a() => 0)\n\n# Indexed systems\nP = Subspace(σz(:i) => -1)  # All spins down\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitaryTransformations.OperatorConstraint","page":"API Reference","title":"UnitaryTransformations.OperatorConstraint","text":"OperatorConstraint\n\nA single constraint defining a sector: an operator and its eigenvalue in that sector.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitaryTransformations.decompose","page":"API Reference","title":"UnitaryTransformations.decompose","text":"decompose(H::QuExpr, P::Subspace)\n\nDecompose H into diagonal and off-diagonal parts with respect to subspace P.\n\nReturns (Hd, Hod) where:\n\nH_d is the block-diagonal part\nH_od is the off-block-diagonal part\nH = Hd + Hod\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.diagonal_part","page":"API Reference","title":"UnitaryTransformations.diagonal_part","text":"diagonal_part(H::QuExpr, P::Subspace)\n\nExtract the block-diagonal part of H with respect to subspace P. This includes terms that preserve P (P·H·P) and terms that preserve Q (Q·H·Q).\n\nNote: Terms classified as MIXED (like σx when not using σpm mode) are skipped. For proper handling, ensure Hamiltonians are expressed in the σ± basis.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.off_diagonal_part","page":"API Reference","title":"UnitaryTransformations.off_diagonal_part","text":"off_diagonal_part(H::QuExpr, P::Subspace)\n\nExtract the off-block-diagonal part of H with respect to subspace P. This includes terms that couple P to Q (P·H·Q + Q·H·P).\n\nNote: MIXED terms (like σx in σz basis, or off-diagonal Lie algebra generators) are included in the off-diagonal part since they contain off-diagonal components that couple different subspaces.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.is_diagonal","page":"API Reference","title":"UnitaryTransformations.is_diagonal","text":"is_diagonal(expr::QuExpr, P::Subspace)\n\nCheck if an expression is purely block-diagonal with respect to subspace P.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.is_off_diagonal","page":"API Reference","title":"UnitaryTransformations.is_off_diagonal","text":"is_off_diagonal(expr::QuExpr, P::Subspace)\n\nCheck if an expression is purely off-block-diagonal with respect to subspace P.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.solve_for_generator","page":"API Reference","title":"UnitaryTransformations.solve_for_generator","text":"solve_for_generator(H_d::QuExpr, V_od::QuExpr, P::Subspace)\n\nSolve [S, Hd] = -Vod for the generator S.\n\nThis is the core equation in Schrieffer-Wolff: we need to find S such that the commutator with the diagonal part cancels the off-diagonal perturbation.\n\nThe fundamental solution in the energy eigenbasis is:     S{ij} = V{ij} / (Ei - Ej)\n\nTwo methods are automatically selected based on operator types:\n\nEigenoperator method (TLS, bosons, N-level transitions): For operators O  where [H_d, O] = ε·O, the solution is S = V/ε directly.\nMatrix-element method (SU(N) Lie algebras): Convert to the Cartan-Weyl  (transition) basis where operators ARE eigenoperators, apply S{ij} = V{ij}/(Ei - Ej), then convert back.\n\nUses Symbolics.jl for proper symbolic division, allowing denominators like (Δ - ω).\n\nArguments\n\nH_d: The diagonal (unperturbed) Hamiltonian\nV_od: The off-diagonal perturbation to be eliminated\nP: The subspace defining the block structure\n\nReturns\n\nS: The generator of the transformation\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.solve_for_generator_eigenoperator","page":"API Reference","title":"UnitaryTransformations.solve_for_generator_eigenoperator","text":"solve_for_generator_eigenoperator(H_d::QuExpr, V_od::QuExpr, P::Subspace)\n\nSolve [S, Hd] = -Vod using the eigenoperator method.\n\nThis method works for operators O where [H_d, O] = ε·O (eigenoperators of the  adjoint action). The solution is simply S = V/ε.\n\nExamples of eigenoperators:\n\nσ± for TLS with H_d ∝ σz: [σz, σ±] = ±2σ±\na, a† for bosons with H_d ∝ a†a: [a†a, a] = -a, [a†a, a†] = a†\n|i⟩⟨j| for N-level with diagonal Hd: [Hd, |i⟩⟨j|] = (Ei - Ej)|i⟩⟨j|\n\nFor each term in Vod, the corresponding term in S is Vterm / ε.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.solve_for_generator_lie","page":"API Reference","title":"UnitaryTransformations.solve_for_generator_lie","text":"solve_for_generator_lie(H_d::QuExpr, V_od::QuExpr, N::Int, generators::Tuple; \n                        algebra_id=SU3_ALGEBRA_ID)\n\nSolve [S, Hd] = -Vod for the generator S using the matrix-element method.\n\nThis approach works for any SU(N) Lie algebra by:\n\nComputing energy eigenvalues Ei from Hd\nConverting V_od to Cartan-Weyl basis (transition operators |i⟩⟨j|)\nApplying the fundamental formula: S{ij} = V{ij} / (Ei - Ej)\nConverting S back to Gell-Mann basis\n\nThe key insight is that transition operators |i⟩⟨j| ARE eigenoperators:     [Hd, |i⟩⟨j|] = (Ei - E_j)|i⟩⟨j|\n\nArguments\n\nH_d: The diagonal Hamiltonian (in diagonal generators only)\nV_od: The off-diagonal perturbation to be eliminated\nN: Dimension of the representation (2 for SU(2), 3 for SU(3))\ngenerators: Tuple of SU(N) generators (from su_generators)\nalgebra_id: The algebra identifier (default: SU3ALGEBRAID)\n\nReturns\n\nS: The generator of the transformation\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.compute_energy_denominator","page":"API Reference","title":"UnitaryTransformations.compute_energy_denominator","text":"compute_energy_denominator(H_d::QuExpr, term::QuTerm, P::Subspace)\n\nCompute the energy denominator for a given off-diagonal term.\n\nFor an off-diagonal operator O, computes ε where [Hd, O] = ε·O. This is the energy difference Ei - E_j for the transition that O represents.\n\nReturns the energy denominator as a Symbolics Num expression, or nothing if the operator commutes with H_d (degenerate case).\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.compute_energy_eigenvalues","page":"API Reference","title":"UnitaryTransformations.compute_energy_eigenvalues","text":"compute_energy_eigenvalues(H_d::QuExpr, N::Int, algebra_id::UInt16)\n\nCompute energy eigenvalues for an N-level system from a diagonal Hamiltonian expressed in terms of Lie algebra generators.\n\nFor SU(N), the diagonal generators (Cartan subalgebra) have known eigenvalues. This function extracts the coefficients from H_d and computes Eᵢ for each state.\n\nReturns a vector of symbolic expressions [E₁, E₂, ..., Eₙ].\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.detect_lie_algebra_system","page":"API Reference","title":"UnitaryTransformations.detect_lie_algebra_system","text":"detect_lie_algebra_system(V_od::QuExpr)\n\nDetect if V_od contains Lie algebra generators and return information about the algebra.\n\nReturns nothing if no Lie algebra operators found, or a NamedTuple with:\n\nN: dimension of the algebra (2 for SU(2), 3 for SU(3))\nalgebra_id: the UInt16 algebra identifier\nname: the generator name (e.g., :λ)\ninds: the indices tuple\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.project_to_subspace","page":"API Reference","title":"UnitaryTransformations.project_to_subspace","text":"project_to_subspace(H::QuExpr, P::Subspace)\n\nProject an operator onto the subspace P.\n\nThis replaces diagonal operators by their eigenvalues in P:\n\nσz → eigenvalue (e.g., -1 for spin down)\nσ⁺σ⁻ → 0 for spin down, 1 for spin up\na†a → eigenvalue (e.g., 0 for vacuum)\n\nAnd removes any remaining off-diagonal terms.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.bch_transform","page":"API Reference","title":"UnitaryTransformations.bch_transform","text":"bch_transform(S::QuExpr, A::QuExpr; order::Int=4)\n\nCompute e^S A e^{-S} using the BCH formula to the specified order.\n\nThis computes the adjoint action of e^S on an operator A:     e^S A e^{-S} = A + [S,A] + (1/2!)[S,[S,A]] + (1/3!)[S,[S,[S,A]]] + ...\n\nArguments\n\nS: The generator (typically anti-Hermitian: S† = -S)\nA: The operator to transform (e.g., a Hamiltonian)\norder: Number of nested commutators to include (default: 4)\n\nExample\n\nusing QuantumAlgebra, UnitaryTransformations, Symbolics\n@variables g Δ\n\n# Generator from SW transformation\nS = (g/Δ) * (a'()*σm() - a()*σp())\n\n# Transform the Hamiltonian\nH = Δ/2 * σz() + g * (a'()*σm() + a()*σp())\nH_transformed = bch_transform(S, H; order=2)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.commutator_series","page":"API Reference","title":"UnitaryTransformations.commutator_series","text":"commutator_series(S::QuExpr, H::QuExpr, order::Int)\n\nCompute the BCH expansion of e^S H e^{-S} to the given order.\n\ne^S H e^{-S} = Σₙ (1/n!) [S, [S, [..., [S, H]...]]]  (n nested commutators)\n\nThe expansion is truncated at order nested commutators.\n\nArguments\n\nS: The generator of the unitary transformation (anti-Hermitian: S† = -S)\nH: The operator to transform\norder: Maximum number of nested commutators to include\n\nReturns\n\nThe transformed operator as a QuExpr\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.nested_commutator","page":"API Reference","title":"UnitaryTransformations.nested_commutator","text":"nested_commutator(S::QuExpr, H::QuExpr, n::Int)\n\nCompute the n-fold nested commutator [S, [S, [..., [S, H]...]]] with S appearing n times.\n\nn=0 returns H\nn=1 returns [S, H]\nn=2 returns [S, [S, H]]\netc.\n\n\n\n\n\nnested_commutator(operators::Vector{QuExpr})\n\nCompute the left-nested commutator [...[[A₁, A₂], A₃], ..., Aₙ].\n\n\n\n\n\nnested_commutator(H::FourierHamiltonian, indices)\n\nCompute the nested commutator for given Fourier indices.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.simplify_coefficients","page":"API Reference","title":"UnitaryTransformations.simplify_coefficients","text":"simplify_coefficients(expr::QuExpr; mode::Symbol=:fast)\n\nSimplify all Symbolics coefficients in a QuExpr. Returns a new QuExpr with simplified coefficients.\n\nModes\n\n:none - No simplification (fastest, for internal computations)\n:fast - Basic expansion only (default, very fast)\n:standard - Use simplify(; expand=true) (slower but more thorough)\n:fractions - Use simplify_fractions (slow, simplifies rational expressions)\n:aggressive - Use full simplify (slowest, most thorough)\n\nNote: The :fractions and :aggressive modes can be extremely slow on complex  expressions due to polynomial GCD and rewriting computations. Use :fast for  most cases - it flattens expressions and combines like terms efficiently.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.substitute_values","page":"API Reference","title":"UnitaryTransformations.substitute_values","text":"substitute_values(expr::QuExpr, values::Dict{Symbol, Number})\n\nSubstitute numerical values for symbolic parameters in a QuExpr.\n\nArguments\n\nexpr: A QuExpr with symbolic coefficients\nvalues: Dict mapping parameter symbols to numerical values\n\nExample\n\nH_P = result.H_P\nvalues = Dict(:g => 0.1, :Δ => 1.0)\nH_numeric = substitute_values(H_P, values)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.extract_coefficient","page":"API Reference","title":"UnitaryTransformations.extract_coefficient","text":"extract_coefficient(expr::QuExpr, target_ops::QuExpr)\n\nExtract the coefficient of a specific operator structure from a QuExpr.\n\nArguments\n\nexpr: The full QuExpr to search\ntarget_ops: The operator structure to match (e.g., a'()*a())\n\nReturns\n\nThe coefficient (Num or Number) if found, nothing otherwise\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.collect_terms","page":"API Reference","title":"UnitaryTransformations.collect_terms","text":"collect_terms(expr::QuExpr)\n\nCollect and display all terms in a QuExpr with their simplified coefficients. Returns a vector of (operatorstring, simplifiedcoefficient) pairs.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.to_latex","page":"API Reference","title":"UnitaryTransformations.to_latex","text":"to_latex(expr::QuExpr; simplify_coeff::Bool=true)\n\nConvert a QuExpr to a LaTeX string with simplified coefficients.\n\nArguments\n\nexpr: The quantum expression to convert\nsimplify_coeff: Whether to simplify coefficients first (default: true)\n\nReturns\n\nA LaTeX string representation of the expression.\n\nExample\n\nH = Δ/2 * σz() + g * (a'() * σm() + a() * σp())\nprintln(to_latex(H))\n\n\n\n\n\nto_latex(result::NamedTuple; simplify_coeff::Bool=true)\n\nConvert a Schrieffer-Wolff result to LaTeX strings.\n\nReturns\n\nA NamedTuple with LaTeX strings for each component:\n\nH_eff: The effective Hamiltonian\nS: The generator\nH_P: The projected Hamiltonian\n\nExample\n\nresult = schrieffer_wolff(H, P; order=2)\nlatex_result = to_latex(result)\nprintln(latex_result.H_P)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.print_latex","page":"API Reference","title":"UnitaryTransformations.print_latex","text":"print_latex(expr::QuExpr; name::String=\"\", display::Bool=true, simplify_coeff::Bool=true)\n\nPrint a QuExpr as LaTeX, optionally wrapped in display math environment.\n\nArguments\n\nexpr: The quantum expression to print\nname: Optional name to show (e.g., \"H_{eff}\")\ndisplay: If true, wrap in \\[ ... \\] for display math\nsimplify_coeff: Whether to simplify coefficients first\n\nExample\n\nprint_latex(result.H_P; name=\"H_P\")\n# Output: H_P = - \\frac{1}{2} \\Delta + ...\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.show_result","page":"API Reference","title":"UnitaryTransformations.show_result","text":"show_result(result::NamedTuple; display::Bool=false, simplify_coeff::Bool=true)\n\nPretty-print all components of a Schrieffer-Wolff result in LaTeX.\n\nArguments\n\nresult: The result from schrieffer_wolff\ndisplay: If true, wrap each in display math environment\nsimplify_coeff: Whether to simplify coefficients\n\nExample\n\nresult = schrieffer_wolff(H, P; order=2)\nshow_result(result)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.param_to_symbolic","page":"API Reference","title":"UnitaryTransformations.param_to_symbolic","text":"param_to_symbolic(p::Param)\n\nConvert a QuantumAlgebra Param to a Symbolics variable. Caches variables to ensure the same param always maps to the same variable.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.symbolic_coefficient","page":"API Reference","title":"UnitaryTransformations.symbolic_coefficient","text":"symbolic_coefficient(term::QuTerm, coeff::Number)\n\nConvert a QuTerm's coefficient (Number + Params) to a single Symbolics expression. Handles both real and complex coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.clear_param_cache!","page":"API Reference","title":"UnitaryTransformations.clear_param_cache!","text":"clear_param_cache!()\n\nClear the parameter to Symbolics variable cache. Useful when starting a new calculation with fresh variables.\n\n\n\n\n\n","category":"function"},{"location":"theory/#theory","page":"Theory","title":"Theory","text":"This section provides the mathematical background for the unitary transformations implemented in this package.","category":"section"},{"location":"theory/#Unitary-Transformations-in-Quantum-Mechanics","page":"Theory","title":"Unitary Transformations in Quantum Mechanics","text":"A unitary transformation maps a Hamiltonian H to a new Hamiltonian tildeH via:\n\ntildeH = U H U^dagger\n\nwhere U is a unitary operator (U^dagger U = mathbb1). The physics is unchanged—the eigenvalues are preserved—but the representation may be simpler or more convenient.\n\nWhen U = e^S for some anti-Hermitian generator S (i.e., S^dagger = -S), the transformed Hamiltonian can be expanded using the Baker-Campbell-Hausdorff (BCH) formula:\n\ne^S H e^-S = H + S H + frac12S S H + frac13S S S H + cdots\n\nThis infinite series becomes tractable when S is small (perturbative) or when the series terminates after a finite number of terms.\n\n","category":"section"},{"location":"theory/#sw_transformation","page":"Theory","title":"Schrieffer-Wolff Transformation","text":"The Schrieffer-Wolff (SW) transformation is a perturbative method for block-diagonalizing Hamiltonians with well-separated energy scales. It was introduced by Schrieffer and Wolff in 1966 to derive the Kondo exchange interaction from the Anderson impurity model.","category":"section"},{"location":"theory/#The-Problem","page":"Theory","title":"The Problem","text":"Consider a Hamiltonian of the form:\n\nH = H_0 + V\n\nwhere:\n\nH_0 is the unperturbed Hamiltonian with known eigenstates grouped into low-energy (P) and high-energy (Q) sectors\nV is a perturbation that couples the P and Q sectors\n\nWe want to find an effective Hamiltonian H_texteff that:\n\nActs only within the low-energy sector P\nCaptures the effects of V to a given order in perturbation theory","category":"section"},{"location":"theory/#The-Transformation","page":"Theory","title":"The Transformation","text":"We seek a unitary U = e^S such that the transformed Hamiltonian:\n\nH_texteff = e^S H e^-S\n\nis block-diagonal with respect to the P and Q subspaces. This means H_texteff has no matrix elements connecting P and Q.","category":"section"},{"location":"theory/#Determining-the-Generator","page":"Theory","title":"Determining the Generator","text":"Decompose the Hamiltonian and generator into block-diagonal and off-block-diagonal parts:\n\nH = H_d + V_od quad S = S_od\n\nwhere:\n\nH_d = P H P + Q H Q (block-diagonal)\nV_od = P H Q + Q H P (off-block-diagonal)\nS_od is purely off-block-diagonal (anti-Hermitian)\n\nThe generator equation at first order is:\n\nS H_d = -V_od\n\nThis is the fundamental equation that determines S. It states that the commutator of S with the diagonal Hamiltonian must cancel the off-diagonal perturbation.","category":"section"},{"location":"theory/#Solving-the-Generator-Equation","page":"Theory","title":"Solving the Generator Equation","text":"For operators O that are eigenoperators of the adjoint action of H_d—meaning H_d O = varepsilon cdot O for some energy varepsilon—the solution is:\n\nS = sum_alpha fracV_alphavarepsilon_alpha\n\nwhere V_alpha are the components of V_od and varepsilon_alpha are the corresponding energy denominators.\n\nExample: For a two-level system with H_d = fracDelta2sigma_z and V_od = gsigma^+:\n\nsigma_z sigma^+ = 2sigma^+, so H_d sigma^+ = Deltasigma^+\nTherefore S = fracgDeltasigma^+ (plus Hermitian conjugate for the sigma^- term)","category":"section"},{"location":"theory/#The-Effective-Hamiltonian","page":"Theory","title":"The Effective Hamiltonian","text":"Using the BCH expansion:\n\nH_texteff = H_d + frac12S V_od + O(V^3)\n\nThe key second-order contribution is:\n\nH^(2) = frac12S V_od\n\nThis generates effective interactions within the low-energy sector that arise from virtual transitions to high-energy states.","category":"section"},{"location":"theory/#Physical-Interpretation","page":"Theory","title":"Physical Interpretation","text":"The SW transformation captures the physics of virtual processes:\n\nThe system starts in the low-energy sector P\nThe perturbation V virtually excites it to high-energy sector Q\nThe system returns to P via another application of V\n\nThis virtual excitation costs energy Delta E and contributes to the effective Hamiltonian as sim V^2Delta E.","category":"section"},{"location":"theory/#Order-by-Order-Expansion","page":"Theory","title":"Order-by-Order Expansion","text":"At higher orders, the SW transformation proceeds iteratively:\n\nOrder Contribution Energy dependence\n0 H_d Original diagonal\n2 frac12S_1 V sim g^2Delta\n3 frac12S_1 S_1 H_d + S_2 V sim g^3Delta^2\n4 Higher nested commutators sim g^4Delta^3\n\nEach order adds terms suppressed by additional powers of gDelta.\n\n","category":"section"},{"location":"theory/#Eigenoperator-Method","page":"Theory","title":"Eigenoperator Method","text":"This package implements two methods for solving the generator equation. The eigenoperator method works for operators that satisfy:\n\nH_d O = varepsilon cdot O\n\nSuch operators are called eigenoperators of the Liouvillian mathcalL_H_d(cdot) = H_d cdot.","category":"section"},{"location":"theory/#Examples-of-Eigenoperators","page":"Theory","title":"Examples of Eigenoperators","text":"System Operator Eigenvalue\nTLS: H_d = fracDelta2sigma_z sigma^+ +Delta\n sigma^- -Delta\nCavity: H_d = omega a^dagger a a^dagger +omega\n a -omega\nN-level: H_d = sum_i E_i vert iranglelangle ivert vert iranglelangle jvert E_i - E_j\n\nFor these operators, the generator is simply:\n\nS = fracOvarepsilon","category":"section"},{"location":"theory/#Composite-Operators","page":"Theory","title":"Composite Operators","text":"Products of eigenoperators are also eigenoperators with additive eigenvalues:\n\nH_d O_1 O_2 = (varepsilon_1 + varepsilon_2) O_1 O_2\n\nExample: For the Jaynes-Cummings interaction a^dagger sigma^-:\n\nH_d a^dagger sigma^- = (omega_c - Delta) a^dagger sigma^-\nEnergy denominator: omega_c - Delta (the detuning)\n\n","category":"section"},{"location":"theory/#Matrix-Element-Method-for-Lie-Algebras","page":"Theory","title":"Matrix-Element Method for Lie Algebras","text":"For SU(N) systems expressed in the Gell-Mann basis, the generators are not eigenoperators of the diagonal Hamiltonian. For example:\n\nlambda_8 lambda_2 neq c cdot lambda_2\n\nInstead, the commutator produces a linear combination of generators.","category":"section"},{"location":"theory/#Cartan-Weyl-Basis","page":"Theory","title":"Cartan-Weyl Basis","text":"The solution is to work in the Cartan-Weyl basis, where the off-diagonal generators are replaced by transition operators:\n\nGell-Mann Cartan-Weyl\nlambda_1 lambda_4 E_12 = vert 1ranglelangle 2vert, E_21 = vert 2ranglelangle 1vert\nlambda_2 lambda_5 E_13 = vert 1ranglelangle 3vert, E_31 = vert 3ranglelangle 1vert\nlambda_3 lambda_6 E_23 = vert 2ranglelangle 3vert, E_32 = vert 3ranglelangle 2vert\n\nThe transition operators are eigenoperators:\n\nH_d vert iranglelangle jvert = (E_i - E_j)vert iranglelangle jvert","category":"section"},{"location":"theory/#Algorithm","page":"Theory","title":"Algorithm","text":"Compute energy eigenvalues E_i from the diagonal Hamiltonian\nConvert V_od from Gell-Mann to Cartan-Weyl basis\nApply inverse Liouvillian: S_ij = V_ij  (E_i - E_j)\nConvert S back to Gell-Mann basis\n\nThis is implemented in solve_for_generator_lie().\n\n","category":"section"},{"location":"theory/#Energy-Denominators","page":"Theory","title":"Energy Denominators","text":"The energy denominators in SW transformations have important physical meaning:","category":"section"},{"location":"theory/#Resonance-Condition","page":"Theory","title":"Resonance Condition","text":"When an energy denominator approaches zero (varepsilon to 0), the perturbation theory breaks down. This indicates a resonance where the two sectors are no longer well-separated.","category":"section"},{"location":"theory/#Example:-Dispersive-Regime","page":"Theory","title":"Example: Dispersive Regime","text":"In circuit QED, the Jaynes-Cummings Hamiltonian has energy denominator Delta = omega_q - omega_c. The dispersive approximation is valid when:\n\ng ll Delta\n\nThe effective Hamiltonian contains the dispersive shift:\n\nchi = -fracg^2Delta\n\nThis diverges as Delta to 0 (resonance), signaling the breakdown of the perturbative treatment.\n\n","category":"section"},{"location":"theory/#Comparison-with-Other-Methods","page":"Theory","title":"Comparison with Other Methods","text":"","category":"section"},{"location":"theory/#vs.-Löwdin-Partitioning","page":"Theory","title":"vs. Löwdin Partitioning","text":"Löwdin partitioning (also called quasi-degenerate perturbation theory) achieves the same goal but works directly with the Hamiltonian matrix rather than through a unitary transformation. SW provides the explicit generator S, which can be useful for understanding the transformation and computing other observables.","category":"section"},{"location":"theory/#vs.-Adiabatic-Elimination","page":"Theory","title":"vs. Adiabatic Elimination","text":"Adiabatic elimination assumes fast variables equilibrate instantly. SW is more systematic and provides higher-order corrections, but requires a perturbative expansion.","category":"section"},{"location":"theory/#vs.-Numerical-Diagonalization","page":"Theory","title":"vs. Numerical Diagonalization","text":"Numerical methods give exact eigenvalues but not analytical expressions. SW produces symbolic results like g^2Delta that reveal the parameter dependence and scaling.\n\n","category":"section"},{"location":"theory/#References","page":"Theory","title":"References","text":"J. R. Schrieffer and P. A. Wolff, \"Relation between the Anderson and Kondo Hamiltonians,\" Phys. Rev. 149, 491 (1966).\nS. Bravyi, D. P. DiVincenzo, and D. Loss, \"Schrieffer-Wolff transformation for quantum many-body systems,\" Ann. Phys. 326, 2793 (2011).\nC. Cohen-Tannoudji, J. Dupont-Roc, and G. Grynberg, Atom-Photon Interactions (Wiley, 1998), Chapter 3.\nM. Wagner, Unitary Transformations in Solid State Physics (North-Holland, 1986).\nW. Magnus, \"On the exponential solution of differential equations for a linear operator,\" Comm. Pure Appl. Math. 7, 649 (1954).\nS. Blanes et al., \"The Magnus expansion and some of its applications,\" Physics Reports 470, 151 (2009).\n\n","category":"section"},{"location":"theory/#magnus_expansion","page":"Theory","title":"Magnus Expansion","text":"The Magnus expansion is a technique for solving time-dependent Schrödinger equations and computing effective Hamiltonians for periodically driven (Floquet) systems.","category":"section"},{"location":"theory/#The-Problem-2","page":"Theory","title":"The Problem","text":"Consider a time-dependent Schrödinger equation:\n\nifracpartial Upartial t = H(t) U(t)\n\nwhere H(t) is periodic with period T = 2piomega. We want to find an effective time-independent Hamiltonian H_texteff such that after one period:\n\nU(T) = e^-i H_texteff T","category":"section"},{"location":"theory/#Fourier-Representation","page":"Theory","title":"Fourier Representation","text":"A periodic Hamiltonian can be written in Fourier form:\n\nH(t) = sum_n H_n e^inomega t\n\nwhere the Hermiticity condition requires H_-n = H_n^dagger.","category":"section"},{"location":"theory/#The-Magnus-Series","page":"Theory","title":"The Magnus Series","text":"The solution to the Schrödinger equation can be written as:\n\nU(t) = e^Omega(t)\n\nwhere Omega(t) is the Magnus series:\n\nOmega(t) = Omega_1(t) + Omega_2(t) + Omega_3(t) + cdots\n\nThe effective Hamiltonian is:\n\nH_texteff = iOmega(T)T = sum_k=1^infty Omega_k","category":"section"},{"location":"theory/#Orders-of-the-Expansion","page":"Theory","title":"Orders of the Expansion","text":"First order (k=1):\n\nOmega_1 = H_0\n\nThe leading term is simply the time-averaged Hamiltonian.\n\nSecond order (k=2):\n\nOmega_2 = sum_n0 frac-H_n H_-nnomega\n\nThis captures effects like the Bloch-Siegert shift from counter-rotating drive terms.\n\nHigher orders (k≥3):\n\nFor order k, the Magnus term involves nested commutators with k Fourier components:\n\nOmega_k = sum_substackn_1ldotsn_k  sum_j n_j = 0 C(n_1ldotsn_k)  cdotsH_n_1 H_n_2 H_n_3ldots H_n_k\n\nThe coefficients are:\n\nC(n_1ldotsn_k) = frac1omega^k-1 prod_j=1^k-1 s_j\n\nwhere s_j = n_1 + cdots + n_j are partial sums.","category":"section"},{"location":"theory/#Resonance-Condition-2","page":"Theory","title":"Resonance Condition","text":"The sum sum_j n_j = 0 is the resonance condition. It ensures that only certain combinations of Fourier modes contribute to the effective Hamiltonian.","category":"section"},{"location":"theory/#Reducible-Terms","page":"Theory","title":"Reducible Terms","text":"A term is reducible if any intermediate partial sum s_j = 0. Such terms are excluded because they factorize into products of lower-order terms.","category":"section"},{"location":"theory/#Example:-Circularly-Driven-Qubit","page":"Theory","title":"Example: Circularly Driven Qubit","text":"For a qubit driven by a circular field:\n\nH(t) = fracDelta2sigma_z + fracOmega2(e^iomega tsigma^+ + e^-iomega tsigma^-)\n\nThe Fourier modes are:\n\nH_0 = fracDelta2sigma_z\nH_1 = fracOmega2sigma^+\nH_-1 = fracOmega2sigma^-\n\nThe second-order correction is:\n\nOmega_2 = -fracH_1 H_-1omega = -fracOmega^24omegasigma^+ sigma^- = -fracOmega^24omegasigma_z\n\nThis is the Bloch-Siegert shift — a correction to the qubit frequency proportional to Omega^2omega.","category":"section"},{"location":"theory/#Convergence","page":"Theory","title":"Convergence","text":"The Magnus expansion converges when:\n\nint_0^T H(t)  dt  pi\n\nFor high-frequency driving (omega gg H), convergence is typically rapid.","category":"section"},{"location":"theory/#Physical-Applications","page":"Theory","title":"Physical Applications","text":"Application Key Effect\nNMR Rotating-wave corrections\nTrapped ions Micromotion effects\nCircuit QED AC Stark shifts\nFloquet engineering Artificial gauge fields","category":"section"},{"location":"theory/#Comparison-with-Floquet-Theory","page":"Theory","title":"Comparison with Floquet Theory","text":"The Magnus expansion provides a high-frequency expansion of Floquet theory. While exact Floquet diagonalization gives the full quasienergy spectrum, the Magnus expansion produces analytical expressions valid in the omega gg V regime.","category":"section"},{"location":"examples/#examples","page":"Examples","title":"Examples","text":"This page presents complete physics examples demonstrating the Schrieffer-Wolff transformation. Each example shows the LaTeX output for easy use in publications.","category":"section"},{"location":"examples/#Convergence-Analysis","page":"Examples","title":"Convergence Analysis","text":"The following figure demonstrates how higher-order SW transformations systematically improve the accuracy of the effective Hamiltonian:\n\n(Image: Summary of SW transformations at different orders)\n\nKey observations:\n\nPanel (a): Energy levels of a two-level system. Higher orders capture the curvature better.\nPanel (b): The energy gap E_+ - E_- approaches the exact sqrtDelta^2 + 4varepsilon^2 with higher orders.\nPanel (c): Relative error decreases with increasing SW order.\nPanel (d): Jaynes-Cummings model showing dispersive shift chi and Kerr nonlinearity K (only present at order 4+).","category":"section"},{"location":"examples/#Jaynes-Cummings:-Dispersive-Regime","page":"Examples","title":"Jaynes-Cummings: Dispersive Regime","text":"The Jaynes-Cummings model describes a two-level atom coupled to a single cavity mode:\n\nH = omega_c a^dagger a + fracomega_q2sigma_z + g(a^daggersigma^- + asigma^+)\n\nIn the dispersive regime (Delta = omega_q - omega_c gg g), the Schrieffer-Wolff transformation yields an effective Hamiltonian with a state-dependent frequency shift.\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\nQuantumAlgebra.use_σpm(true)\n\n@variables Δ g  # Δ = detuning, g = coupling\n\n# Hamiltonian (in rotating frame)\nH = Δ/2 * σz() + g * (a'()*σm() + a()*σp())\n\n# Ground state subspace\nP = Subspace(σz() => -1)\n\n# Transform and display results\nresult = schrieffer_wolff(H, P; order=2)\nshow_result(result)\n\nGenerator:\n\nS = frac-g2Delta a^dagger sigma^- + fracg2Delta sigma^+ a\n\nEffective Hamiltonian:\n\nH_texteff = -fracDelta2 - fracg^2Delta a^dagger a + fracg^2 + Delta^2Delta sigma^+ sigma^- + frac2g^2Delta a^dagger sigma^+ sigma^- a\n\nProjected to subspace P (qubit ground state):\n\nH_P = -fracDelta2 - fracg^2Delta a^dagger a","category":"section"},{"location":"examples/#Physical-Interpretation","page":"Examples","title":"Physical Interpretation","text":"The effective Hamiltonian contains:\n\nDispersive shift: chi = -g^2Delta — cavity frequency shifts when qubit is in ground state\nAC Stark shift: Qubit frequency shifts with photon number\n\nThis is the basis for qubit readout in circuit QED!\n\n(Image: Jaynes-Cummings dispersive shift and Kerr nonlinearity)","category":"section"},{"location":"examples/#Extracting-Parameters","page":"Examples","title":"Extracting Parameters","text":"χ = extract_coefficient(result.H_P, a'()*a())\nprintln(to_latex(χ))  # Output: \\frac{-g^{2}}{\\Delta}\n\n# Numerical evaluation\nH_num = substitute_values(result.H_P, Dict(:g => 0.1, :Δ => 1.0))\n# χ = -0.01, matching -g²/Δ\n\n","category":"section"},{"location":"examples/#Two-Level-System-with-Transverse-Field","page":"Examples","title":"Two-Level System with Transverse Field","text":"A qubit in longitudinal and transverse magnetic fields:\n\nH = fracDelta2sigma_z + varepsilonsigma_x\n\nThis textbook problem has an exact solution, making it perfect for verification.\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\nQuantumAlgebra.use_σpm(true)\n\n@variables Δ ε\n\nH = Δ/2 * σz() + ε * (σp() + σm())\nP = Subspace(σz() => -1)\n\nresult = schrieffer_wolff(H, P; order=2)\nprint_latex(result.H_P; name=\"H_P\")\n\nOutput:\n\nH_P = -fracDelta2 - fracvarepsilon^2Delta","category":"section"},{"location":"examples/#Comparison-with-Exact-Solution","page":"Examples","title":"Comparison with Exact Solution","text":"The exact ground state energy is:\n\nE_- = -sqrtfracDelta^24 + varepsilon^2 approx -fracDelta2 - fracvarepsilon^2Delta + O(varepsilon^4)\n\nThe SW result matches the perturbation expansion exactly!\n\n(Image: Two-level system: SW orders vs exact solution)\n\nvarepsilonDelta Exact SW (2nd order) Error\n0.01 -0.50005 -0.5001 0.00%\n0.05 -0.50125 -0.5025 0.00%\n0.10 -0.50499 -0.51 0.02%\n0.20 -0.51980 -0.54 0.28%","category":"section"},{"location":"examples/#Convergence-with-Order","page":"Examples","title":"Convergence with Order","text":"(Image: Convergence of SW expansion)\n\nThe figure shows how the approximation error decreases with increasing SW order. For small perturbations (varepsilonDelta  03), convergence is rapid. For larger coupling, more orders are needed.\n\n","category":"section"},{"location":"examples/#Rabi-Model:-Bloch-Siegert-Shift","page":"Examples","title":"Rabi Model: Bloch-Siegert Shift","text":"The full Rabi model includes counter-rotating terms neglected in the rotating-wave approximation:\n\nH = omega a^dagger a + fracDelta2sigma_z + g(sigma^+ + sigma^-)(a + a^dagger)\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\nQuantumAlgebra.use_σpm(true)\n\n@variables ω Δ g\n\nH = ω * a'()*a() + Δ/2 * σz() + g * (σp() + σm()) * (a() + a'())\nP = Subspace(σz() => -1)\n\nresult = schrieffer_wolff(H, P; order=2)\nprint_latex(result.H_P; name=\"H_P\")\n\nOutput:\n\nH_P = -fracDelta2 + omega a^dagger a - fracg^2Delta - omega a^dagger a - fracg^2Delta + omega a^dagger a + fracg^2Delta + omega - fracg^2Delta + omega (a^dagger)^2 - fracg^2Delta + omega a^2","category":"section"},{"location":"examples/#Physical-Interpretation-2","page":"Examples","title":"Physical Interpretation","text":"Compared to Jaynes-Cummings, the full Rabi model produces:\n\nJC dispersive shift: -g^2(Delta - omega) from rotating terms\nBloch-Siegert shift: -g^2(Delta + omega) from counter-rotating terms\nSqueezing terms: a^2 and (a^dagger)^2 that squeeze the cavity field\n\nThe total dispersive shift combines both contributions:\n\nchi_texttotal = -fracg^2Delta - omega - fracg^2Delta + omega\n\n(Image: Bloch-Siegert shift: JC vs full Rabi model)\n\n","category":"section"},{"location":"examples/#N-Level-Atom-in-a-Cavity","page":"Examples","title":"N-Level Atom in a Cavity","text":"For atoms with more than two levels, use nlevel_ops:\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# 5-level atom: σ[i,j] = |i⟩⟨j|\nσ5 = nlevel_ops(5, :q)\n\nω = [Symbolics.variable(Symbol(\"ω\", i)) for i in 1:5]\n@variables ωc g\n\n# Atom + cavity + dipole coupling |1⟩↔|3⟩\nH = sum(ω[i] * σ5[i,i] for i in 1:5) + \n    ωc * a'()*a() + \n    g * (σ5[1,3] * a'() + σ5[3,1] * a())\n\n# Zero-photon subspace\nP = Subspace(a'()*a() => 0)\n\nresult = schrieffer_wolff(H, P; order=2)\nshow_result(result)\n\nGenerator:\n\nS = fracgomega_1 - omega_3 - omega_c 1ranglelangle 3  a^dagger + fracgomega_3 - omega_1 + omega_c 3ranglelangle 1  a","category":"section"},{"location":"examples/#Physical-Interpretation-3","page":"Examples","title":"Physical Interpretation","text":"Dispersive shift: chi_13 = g^2(omega_1 - omega_3 + omega_c)\nAC Stark shifts on levels 1 and 3\nOther levels (2, 4, 5) appear only with bare energies\n\n","category":"section"},{"location":"examples/#Three-Level-Lambda-System","page":"Examples","title":"Three-Level Lambda System","text":"For systems with SU(N) symmetry, use su_generators:\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# Gell-Mann matrices for SU(3)\nλ = su_generators(3, :λ)\n\n@variables Δ Ω₁ Ω₂\n\n# Lambda system\nH = Δ * λ[8] + Ω₁ * λ[1] + Ω₂ * λ[4]\n\nP = Subspace(λ[8] => 1/sqrt(3))\n\nresult = schrieffer_wolff(H, P; order=2)\nshow_result(result)\n\nThe package automatically detects SU(3) and uses the matrix-element method.","category":"section"},{"location":"examples/#When-to-Use-SU(N)-vs-N-Level","page":"Examples","title":"When to Use SU(N) vs N-Level","text":"Approach Use When\nnlevel_ops Physical atoms, specific transitions\nsu_generators Systems with SU(N) symmetry\n\n","category":"section"},{"location":"examples/#Magnus-Expansion:-Floquet-Systems","page":"Examples","title":"Magnus Expansion: Floquet Systems","text":"The Magnus expansion computes effective Hamiltonians for periodically driven systems. For a Hamiltonian in Fourier representation:\n\nH(t) = sum_n H_n e^inomega t\n\nThe effective Hamiltonian is:\n\nH_texteff = H_0 + Omega_2 + Omega_3 + ldots","category":"section"},{"location":"examples/#Circularly-Driven-Two-Level-System","page":"Examples","title":"Circularly Driven Two-Level System","text":"A qubit driven by a circularly polarized field:\n\nH(t) = fracDelta2sigma_z + fracOmega2left(e^iomega tsigma^+ + e^-iomega tsigma^-right)\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\nQuantumAlgebra.use_σpm(true)\n\n@variables Δ Ω ω\n\n# Fourier modes: H(t) = Σₙ Hₙ exp(inωt)\nmodes = Dict(\n    0  => Δ/2 * σz(),\n    1  => Ω/2 * σp(),\n    -1 => Ω/2 * σm()\n)\n\n# Compute Magnus expansion to 4th order\nresult = magnus_expansion(modes, ω; order=4)\n\nprintln(\"H_eff = \", result.H_eff)\nprintln(\"Ω₂ (Bloch-Siegert) = \", result.Ω2)\nprintln(\"Ω₃ = \", result.Ω3)\n\nOutput (order 2):\n\nOmega_2 = -fracOmega^24omegasigma_z\n\nThis is the Bloch-Siegert shift — a correction to the qubit frequency due to counter-rotating drive terms.","category":"section"},{"location":"examples/#Higher-Order-Corrections","page":"Examples","title":"Higher-Order Corrections","text":"The Magnus expansion can be computed to arbitrary order:\n\n# High-order expansion\nresult = magnus_expansion(modes, ω; order=6)\n\n# Access individual orders\nprintln(\"Order 3: \", result.Ω3)  # ~ -ΔΩ²/(4ω²)\nprintln(\"Order 4: \", result.Ω4)  # ~ +Δ²Ω²/(4ω³)\nprintln(\"Order 5: \", result.Ω5)  # ~ -Δ³Ω²/(4ω⁴)\n\nPattern: For k ≥ 2, each order contributes:\n\nOmega_k = (-1)^k-1 fracDelta^k-2 Omega^24omega^k-1 sigma_z\n\nThis geometric series sums to the exact Bloch-Siegert result:\n\nH_texteff = fracDelta2left(1 - fracOmega^22omega(omega + Delta)right)sigma_z","category":"section"},{"location":"examples/#Multiple-Driving-Frequencies","page":"Examples","title":"Multiple Driving Frequencies","text":"For Hamiltonians with multiple Fourier components:\n\n@variables Δ Ω₁ Ω₂ ω\n\n# Bichromatic driving\nmodes = Dict(\n    0  => Δ/2 * σz(),\n    1  => Ω₁/2 * σp(),\n    -1 => Ω₁/2 * σm(),\n    2  => Ω₂/2 * σp(),\n    -2 => Ω₂/2 * σm()\n)\n\nresult = magnus_expansion(modes, ω; order=3)","category":"section"},{"location":"examples/#Hermiticity-Check","page":"Examples","title":"Hermiticity Check","text":"The Magnus expansion verifies that your Hamiltonian is Hermitian:\n\n# This will check H₋ₙ = Hₙ† automatically\nresult = magnus_expansion(modes, ω; check_hermitian=true)\n\n# Skip the check if you know what you're doing\nresult = magnus_expansion(modes, ω; check_hermitian=false)\n\n","category":"section"},{"location":"examples/#Running-the-Examples","page":"Examples","title":"Running the Examples","text":"Complete example files are in the examples/ directory:\n\njulia --project examples/jaynes_cummings_dispersive.jl\njulia --project examples/two_level_system.jl\njulia --project examples/rabi_bloch_siegert.jl\njulia --project examples/three_level_atom.jl\njulia --project examples/driven_qubit.jl  # Magnus expansion\n\n","category":"section"},{"location":"examples/#Tips","page":"Examples","title":"Tips","text":"Use show_result(result) to see all components in LaTeX\nUse to_latex(expr) to get a LaTeX string for any expression\nUse extract_coefficient(expr, op) to get specific parameters\nUse substitute_values(expr, Dict(...)) for numerical evaluation\nUse result.Ω3 to access individual Magnus orders (or result.orders[3])","category":"section"},{"location":"#UnitaryTransformations.jl","page":"Home","title":"UnitaryTransformations.jl","text":"A Julia package for performing symbolic unitary transformations on quantum Hamiltonians.\n\n(Image: Summary of Schrieffer-Wolff transformations at different orders)","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"Unitary transformations are essential tools in quantum mechanics for:\n\nSimplifying Hamiltonians by eliminating unwanted couplings\nDeriving effective theories that capture low-energy physics\nBlock-diagonalizing systems with separated energy scales\nChanging to more convenient representations (e.g., polaron frame)\n\nThis package provides symbolic implementations that produce analytical expressions rather than numerical results. For example, the dispersive shift in circuit QED is computed as -g²/Δ, not as a floating-point number.","category":"section"},{"location":"#Available-Transformations","page":"Home","title":"Available Transformations","text":"Transformation Purpose Status\nSchrieffer-Wolff Block-diagonalize Hamiltonians, derive effective low-energy theories ✓ Implemented\nMagnus Expansion Effective Hamiltonians for periodically driven (Floquet) systems ✓ Implemented\nLang-Firsov Eliminate linear electron-phonon coupling (polaron frame) Planned\nBogoliubov Diagonalize quadratic bosonic Hamiltonians Planned\nHolstein-Primakoff Map spin operators to bosonic operators Planned","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# Use σ± basis (recommended)\nQuantumAlgebra.use_σpm(true)\n\n# Define symbolic parameters\n@variables Δ g\n\n# Jaynes-Cummings Hamiltonian\nH = Δ/2 * σz() + g * (a'()*σm() + a()*σp())\n\n# Define the low-energy subspace\nP = Subspace(σz() => -1)  # qubit ground state\n\n# Perform Schrieffer-Wolff transformation\nresult = schrieffer_wolff(H, P; order=2)\n\n# The effective Hamiltonian\nprintln(result.H_P)\n# Output: -Δ/2 + (-g²/Δ) a†a","category":"section"},{"location":"#Supported-Quantum-Systems","page":"Home","title":"Supported Quantum Systems","text":"The package works with a variety of quantum systems provided by QuantumAlgebra.jl:\n\nSystem Operators Example\nTwo-level systems σx(), σy(), σz(), σp(), σm() Qubits, spin-1/2\nBosonic modes a(), a'() Cavities, phonons\nN-level atoms nlevel_ops(N, :name) Multi-level atoms\nSU(N) systems su_generators(N, :name) 3-level Λ systems\nFermions f(:name), f'(:name) Electrons\n\nThese can be combined freely—for example, an N-level atom coupled to a bosonic cavity.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/volkerkarle/UnitaryTransformations.jl\")\n\nDependencies (automatically installed):\n\nQuantumAlgebra.jl — Symbolic quantum operator algebra\nSymbolics.jl — Computer algebra system","category":"section"},{"location":"#Documentation-Structure","page":"Home","title":"Documentation Structure","text":"Pages = [\"theory.md\", \"tutorial.md\", \"examples.md\", \"api.md\"]\nDepth = 1","category":"section"},{"location":"#[Theory](@ref-theory)","page":"Home","title":"Theory","text":"Mathematical background on unitary transformations, including the Schrieffer-Wolff method, Magnus expansion, and the Baker-Campbell-Hausdorff formula.","category":"section"},{"location":"#[Tutorial](@ref-tutorial)","page":"Home","title":"Tutorial","text":"Step-by-step guide to using the Schrieffer-Wolff transformation.","category":"section"},{"location":"#[Examples](@ref-examples)","page":"Home","title":"Examples","text":"Physics applications: Jaynes-Cummings, Rabi model, multi-level atoms, Floquet systems.","category":"section"},{"location":"#[API-Reference](@ref-api)","page":"Home","title":"API Reference","text":"Complete function documentation.","category":"section"},{"location":"#Package-Philosophy","page":"Home","title":"Package Philosophy","text":"Symbolic over numeric: Results are analytical expressions that can be simplified, manipulated, and substituted.\nAutomatic method selection: The package chooses the optimal algorithm based on the operator types present.\nExtensible design: New transformations can be added as separate modules while sharing the infrastructure.\nVerified correctness: Extensive tests verify mathematical identities and compare with known results.","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"If you use this package in your research:\n\n@software{UnitaryTransformations.jl,\n  author = {Karle, Volker},\n  title = {UnitaryTransformations.jl: Symbolic Unitary Transformations for Quantum Hamiltonians},\n  url = {https://github.com/volkerkarle/UnitaryTransformations.jl},\n  year = {2025}\n}","category":"section"},{"location":"tutorial/#tutorial","page":"Tutorial","title":"Tutorial","text":"This tutorial walks through the Schrieffer-Wolff transformation step by step. For the mathematical background, see the Theory page.","category":"section"},{"location":"tutorial/#Overview","page":"Tutorial","title":"Overview","text":"The Schrieffer-Wolff (SW) transformation finds an effective Hamiltonian that acts within a chosen subspace by perturbatively eliminating couplings to other subspaces. This is useful when:\n\nYou have a system with well-separated energy scales\nYou want to derive an effective low-energy theory\nYou need analytical expressions for perturbative corrections","category":"section"},{"location":"tutorial/#Step-1:-Set-Up-the-System","page":"Tutorial","title":"Step 1: Set Up the System","text":"Let's work with a concrete example: a two-level system (qubit) coupled to a harmonic oscillator (the Jaynes-Cummings model).\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# Use σ± basis - important for SW to work correctly with spins\nQuantumAlgebra.use_σpm(true)\n\n# Define symbolic parameters\n@variables Δ g  # Δ = qubit-oscillator detuning, g = coupling strength\n\n# Jaynes-Cummings Hamiltonian (in rotating frame)\nH = Δ/2 * σz() + g * (a'()*σm() + a()*σp())\n\nThe Hamiltonian describes:\n\nA qubit with splitting Delta (the sigma_z term)\nCoupling to an oscillator mode (the a^dagger sigma^- and a sigma^+ terms)","category":"section"},{"location":"tutorial/#Step-2:-Define-the-Subspace","page":"Tutorial","title":"Step 2: Define the Subspace","text":"We need to specify which states belong to the low-energy subspace P. For this example, we choose the qubit ground state:\n\n# P = states where σz = -1 (qubit in ground state |g⟩)\nP = Subspace(σz() => -1)\n\nThe Subspace type specifies expectation values of operators in the subspace. Here, we say that in subspace P, the operator sigma_z has eigenvalue -1.","category":"section"},{"location":"tutorial/#Multiple-Constraints","page":"Tutorial","title":"Multiple Constraints","text":"For more complex systems, you can specify multiple constraints:\n\n# Subspace with qubit ground state AND zero photons\nP = Subspace(σz() => -1, a'()*a() => 0)","category":"section"},{"location":"tutorial/#Step-3:-Understand-the-Decomposition","page":"Tutorial","title":"Step 3: Understand the Decomposition","text":"The SW transformation requires splitting H into diagonal and off-diagonal parts with respect to P:\n\nH_d, V_od = decompose(H, P)\n\nprintln(\"Diagonal:     \", H_d)\nprintln(\"Off-diagonal: \", V_od)\n\nOutput:\n\nDiagonal:     -0.5Δ + Δ σ⁺σ⁻\nOff-diagonal: g a†σ⁻ + g a σ⁺\n\nDiagonal (H_d): Operators that don't change the subspace (like sigma^+sigma^-, a^dagger a)\nOff-diagonal (V_od): Operators that connect P and Q subspaces (like sigma^+, sigma^-)","category":"section"},{"location":"tutorial/#Step-4:-Perform-the-Transformation","page":"Tutorial","title":"Step 4: Perform the Transformation","text":"Now apply the Schrieffer-Wolff transformation:\n\nresult = schrieffer_wolff(H, P; order=2)\n\nThis returns a named tuple with:\n\nresult.S - The generator of the unitary transformation e^S\nresult.H_eff - The block-diagonal effective Hamiltonian\nresult.H_P - The effective Hamiltonian projected onto subspace P","category":"section"},{"location":"tutorial/#Higher-Orders","page":"Tutorial","title":"Higher Orders","text":"You can go to higher orders for more accuracy:\n\nresult_4th = schrieffer_wolff(H, P; order=4)\n\nFor orders 4 and above, enable parallel computation for better performance:\n\n# Start Julia with threads: julia -t 4\nresult_4th = schrieffer_wolff(H, P; order=4, parallel=true)\n\nOrder Approx. Time Physics Captured\n2 ~50 ms Dispersive shifts\n4 ~0.4 s Kerr nonlinearity, Bloch-Siegert\n5 ~1.5 s Higher-order corrections\n6 ~50 s Research applications\n\nSimplification modes: Control the speed/simplification trade-off:\n\n# Fastest: no simplification (expressions may be verbose)\nresult = schrieffer_wolff(H, P; order=4, simplify_mode=:none)\n\n# Default: fast expansion (recommended)\nresult = schrieffer_wolff(H, P; order=4, simplify_mode=:fast)\n\n# Thorough: full algebraic simplification (slower)\nresult = schrieffer_wolff(H, P; order=4, simplify_mode=:standard)","category":"section"},{"location":"tutorial/#Step-5:-Analyze-the-Results","page":"Tutorial","title":"Step 5: Analyze the Results","text":"","category":"section"},{"location":"tutorial/#The-Generator","page":"Tutorial","title":"The Generator","text":"println(\"Generator S = \", result.S)\n# S = (g/Δ) a†σ⁻ + (-g/Δ) a σ⁺\n\nThe generator S is anti-Hermitian (S^dagger = -S) and satisfies:\n\nS H_d = -V_od","category":"section"},{"location":"tutorial/#The-Effective-Hamiltonian","page":"Tutorial","title":"The Effective Hamiltonian","text":"# Collect and display all terms with simplified coefficients\nterms = collect_terms(result.H_eff)\nfor (op, coeff) in terms\n    println(\"  \", coeff, \"  \", op)\nend\n\nOutput:\n\n  -0.5Δ        𝟙\n  -(g²)/Δ      a†a\n  Δ + (g²)/Δ   σ⁺σ⁻\n  ...","category":"section"},{"location":"tutorial/#The-Projected-Hamiltonian","page":"Tutorial","title":"The Projected Hamiltonian","text":"For many applications, we only care about the subspace P:\n\nprintln(\"H_P = \", result.H_P)\n# H_P = -0.5Δ + (-(g²)/Δ) a†a\n\nThis is the dispersive Hamiltonian: the cavity frequency is shifted by -g^2Delta when the qubit is in the ground state!","category":"section"},{"location":"tutorial/#Step-6:-Extract-Physical-Parameters","page":"Tutorial","title":"Step 6: Extract Physical Parameters","text":"Use utility functions to extract specific coefficients:\n\n# Get the dispersive shift (coefficient of a†a)\nχ = extract_coefficient(result.H_P, a'()*a())\nprintln(\"Dispersive shift χ = \", χ)\n# Output: -(g²)/Δ","category":"section"},{"location":"tutorial/#Step-7:-Numerical-Evaluation","page":"Tutorial","title":"Step 7: Numerical Evaluation","text":"Substitute numerical values to get concrete numbers:\n\nH_numeric = substitute_values(result.H_P, Dict(:g => 0.1, :Δ => 1.0))\nprintln(\"H_P with g=0.1, Δ=1.0: \", H_numeric)","category":"section"},{"location":"tutorial/#Step-8:-LaTeX-Output","page":"Tutorial","title":"Step 8: LaTeX Output","text":"For publications and documentation, you can output results in LaTeX:\n\n# Convert a single expression to LaTeX\nprintln(to_latex(result.H_P))\n# Output: - \\frac{1}{2} \\Delta + \\frac{-g^{2}}{\\Delta} {a}^{\\dagger} {a}\n\n# Pretty-print with a name\nprint_latex(result.H_P; name=\"H_P\")\n# Output: H_P = - \\frac{1}{2} \\Delta + \\frac{-g^{2}}{\\Delta} {a}^{\\dagger} {a}\n\n# Show all components of the result\nshow_result(result)\n\nThe show_result function prints the generator S, effective Hamiltonian H_texteff, and projected Hamiltonian H_P in LaTeX format.","category":"section"},{"location":"tutorial/#Complete-Example","page":"Tutorial","title":"Complete Example","text":"Here's the full code:\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# Setup\nQuantumAlgebra.use_σpm(true)\n\n# Define symbolic parameters and Hamiltonian\n@variables Δ g\nH = Δ/2 * σz() + g * (a'()*σm() + a()*σp())\n\n# Define subspace and transform\nP = Subspace(σz() => -1)\nresult = schrieffer_wolff(H, P; order=2)\n\n# Analyze results\nprintln(\"Effective Hamiltonian in ground state subspace:\")\nfor (op, coeff) in collect_terms(result.H_P)\n    println(\"  \", coeff, \"  \", op)\nend\n\n# Extract dispersive shift\nχ = extract_coefficient(result.H_P, a'()*a())\nprintln(\"\\nDispersive shift: χ = \", χ)\nprintln(\"Expected: -g²/Δ\")\n\n","category":"section"},{"location":"tutorial/#N-Level-Atoms","page":"Tutorial","title":"N-Level Atoms","text":"The package supports N-level atomic systems using QuantumAlgebra's nlevel_ops:\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# Create 5-level atom operators: σ[i,j] = |i⟩⟨j|\nσ5 = nlevel_ops(5, :q)\n\n# Define level energies and coupling\nω = [Symbolics.variable(Symbol(\"ω\", i)) for i in 1:5]\n@variables ωc g\n\n# Hamiltonian: 5-level atom + cavity, coupling levels 1↔3\nH = sum(ω[i] * σ5[i,i] for i in 1:5) + \n    ωc * a'()*a() + \n    g * (σ5[1,3] * a'() + σ5[3,1] * a())\n\n# Zero-photon subspace\nP = Subspace(a'()*a() => 0)\n\nresult = schrieffer_wolff(H, P; order=2)\nprintln(\"Effective Hamiltonian:\")\nprintln(result.H_eff)\n\nThe result contains dispersive shifts and AC Stark corrections for all levels.\n\n","category":"section"},{"location":"tutorial/#SU(N)-Systems","page":"Tutorial","title":"SU(N) Systems","text":"For systems described by SU(N) Lie algebras, the package automatically detects and uses the matrix-element method:\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# SU(3) generators (Gell-Mann matrices)\nλ = su_generators(3, :λ)\n\n@variables Δ ω g\n\n# Three-level Lambda system\nH = Δ * λ[8] + ω * λ[7] + g * λ[2]\n\n# Subspace defined by λ₈ eigenvalue\nP = Subspace(λ[8] => 0.5)\n\n# Automatically uses matrix-element method for SU(3)\nresult = schrieffer_wolff(H, P; order=2)\n\n","category":"section"},{"location":"tutorial/#Key-Points","page":"Tutorial","title":"Key Points","text":"Always use QuantumAlgebra.use_σpm(true) for SW transformations with spins\nDefine subspace carefully - this determines what \"diagonal\" means\nUse collect_terms to see simplified coefficients\nThe physics is in the coefficients - extract them with extract_coefficient\nN-level and SU(N) systems are automatically handled with appropriate methods\nUse parallel=true for orders 4+ and start Julia with -t 4 or more threads\nUse simplify_mode=:none for maximum speed when exploring","category":"section"},{"location":"tutorial/#Next-Steps","page":"Tutorial","title":"Next Steps","text":"See Examples for complete physics applications\nSee Theory for mathematical details\nSee API Reference for function documentation","category":"section"}]
}
