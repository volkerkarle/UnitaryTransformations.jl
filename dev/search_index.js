var documenterSearchIndex = {"docs":
[{"location":"api/#api","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Main-Functions","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api/#Schrieffer-Wolff-Transformation","page":"API Reference","title":"Schrieffer-Wolff Transformation","text":"","category":"section"},{"location":"api/#Subspace-Definition","page":"API Reference","title":"Subspace Definition","text":"","category":"section"},{"location":"api/#Hamiltonian-Decomposition","page":"API Reference","title":"Hamiltonian Decomposition","text":"","category":"section"},{"location":"api/#Generator-Solution","page":"API Reference","title":"Generator Solution","text":"The core operation in Schrieffer-Wolff is solving S H_d = -V_od for the generator S.","category":"section"},{"location":"api/#Main-Function","page":"API Reference","title":"Main Function","text":"","category":"section"},{"location":"api/#Method-Specific-Functions","page":"API Reference","title":"Method-Specific Functions","text":"Two methods are available, automatically selected based on the operator types:\n\nThe eigenoperator method works when H_d O = varepsilon cdot O (TLS, bosons, N-level transitions).\n\nThe Lie algebra method works for SU(N) systems by converting to the Cartan-Weyl basis where generators become eigenoperators.","category":"section"},{"location":"api/#Supporting-Functions","page":"API Reference","title":"Supporting Functions","text":"","category":"section"},{"location":"api/#Projection","page":"API Reference","title":"Projection","text":"","category":"section"},{"location":"api/#BCH-Expansion","page":"API Reference","title":"BCH Expansion","text":"The Baker-Campbell-Hausdorff expansion is used to compute e^S H e^-S.\n\n","category":"section"},{"location":"api/#Symbolic-Utilities","page":"API Reference","title":"Symbolic Utilities","text":"","category":"section"},{"location":"api/#Coefficient-Manipulation","page":"API Reference","title":"Coefficient Manipulation","text":"","category":"section"},{"location":"api/#LaTeX-Output","page":"API Reference","title":"LaTeX Output","text":"","category":"section"},{"location":"api/#Parameter-Conversion","page":"API Reference","title":"Parameter Conversion","text":"Functions for converting between QuantumAlgebra's Param and Symbolics.jl variables:\n\n","category":"section"},{"location":"api/#Re-exported-from-QuantumAlgebra","page":"API Reference","title":"Re-exported from QuantumAlgebra","text":"The following functions are re-exported for convenience:\n\ncomm(A, B) - Compute commutator A B = AB - BA\nnormal_form(expr) - Normal-order an operator expression\na(), a'() - Bosonic annihilation/creation operators\nœÉx(), œÉy(), œÉz() - Pauli matrices\nœÉp(), œÉm() - Raising/lowering operators (when use_œÉpm(true))\nnlevel_ops(N, name) - N-level transition operators iranglelangle j\nsu_generators(N, name) - SU(N) generators (generalized Gell-Mann matrices)\n\n","category":"section"},{"location":"api/#Symbolic-Parameters","page":"API Reference","title":"Symbolic Parameters","text":"Use Symbolics.jl @variables to define symbolic parameters:\n\nusing Symbolics\n@variables Œî g œâ  # Define symbolic parameters\n\nFor N-level systems with indexed parameters:\n\n# Create œâ‚ÇÅ, œâ‚ÇÇ, ..., œâ‚Çô\nœâ = [Symbolics.variable(Symbol(\"œâ\", i)) for i in 1:N]\n\n","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#SWResult","page":"API Reference","title":"SWResult","text":"The schrieffer_wolff function returns a named tuple:\n\nresult = schrieffer_wolff(H, P; order=2)\n\nresult.S      # Generator of the transformation\nresult.H_eff  # Block-diagonal effective Hamiltonian  \nresult.H_P    # H_eff projected onto subspace P","category":"section"},{"location":"api/#Subspace","page":"API Reference","title":"Subspace","text":"# Single constraint\nP = Subspace(œÉz() => -1)\n\n# Multiple constraints\nP = Subspace(œÉz() => -1, a'()*a() => 0)\n\n# N-level constraint\nP = Subspace(a'()*a() => 0)  # zero photons","category":"section"},{"location":"api/#Classification-Enums","page":"API Reference","title":"Classification Enums","text":"The package uses classification enums for operator analysis:\n\nDIAGONAL   # Operator preserves the subspace\nRAISING    # Operator raises out of subspace P\nLOWERING   # Operator lowers into subspace P\nMIXED      # Operator has mixed character\n\n","category":"section"},{"location":"api/#Internal-Functions","page":"API Reference","title":"Internal Functions","text":"These functions are not exported but may be useful for advanced users:","category":"section"},{"location":"api/#Lie-Algebra-Support","page":"API Reference","title":"Lie Algebra Support","text":"# Get generators for detected Lie algebra\nget_generators_for_lie_system(lie_info::NamedTuple)\n\n# Convert between bases\ngellmann_to_cartan_weyl(V_od, N, algebra_id)\ncartan_weyl_to_gellmann(transitions, N, generators)","category":"section"},{"location":"api/#Operator-Classification","page":"API Reference","title":"Operator Classification","text":"# Classify a single term\nclassify_term(term::QuTerm, coeff, constraints)\n\n# Check if operator contains only specific types\nhas_only_bosons(term::QuTerm)\nhas_only_tls(term::QuTerm)","category":"section"},{"location":"api/#UnitaryTransformations.schrieffer_wolff","page":"API Reference","title":"UnitaryTransformations.schrieffer_wolff","text":"schrieffer_wolff(H::QuExpr, P::Subspace; order::Int=2)\n\nPerform the Schrieffer-Wolff transformation on Hamiltonian H with respect  to the low-energy subspace P.\n\nThe transformation finds a unitary U = e^S such that H_eff = e^S H e^{-S} is block-diagonal with respect to P and Q = 1-P, up to the specified order in perturbation theory.\n\nArguments\n\nH: The full Hamiltonian to transform\nP: The low-energy subspace definition\norder: Perturbation theory order (default: 2)\nsimplify_generator: Whether to simplify the generator S (default: false). Simplifying S can be very slow at high orders due to GCD computations on complex symbolic fractions. Set to true if you need simplified S.\n\nReturns\n\nNamed tuple (H_eff, S, H_P) where:\nH_eff: The full block-diagonal effective Hamiltonian\nS: The generator of the transformation\nH_P: The effective Hamiltonian projected onto subspace P\n\nExample\n\nusing QuantumAlgebra, UnitaryTransformations, Symbolics\n\n# Jaynes-Cummings in dispersive regime\n@variables œâ Œî g  # œâ = cavity frequency, Œî = qubit splitting, g = coupling strength\n\nH = œâ * a'()*a() + Œî/2 * œÉz() + g * (a'()*œÉm() + a()*œÉp())\n\n# Transform to eliminate qubit-photon coupling\nP = Subspace(œÉz() => -1)  # qubit ground state\nresult = schrieffer_wolff(H, P; order=2)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.sw_generator","page":"API Reference","title":"UnitaryTransformations.sw_generator","text":"sw_generator(H::QuExpr, P::Subspace; order::Int=1)\n\nCompute only the generator S for the Schrieffer-Wolff transformation, without computing the full effective Hamiltonian.\n\nThis is useful when you only need S, or want to manually compute the transformation using bch_transform.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.Subspace","page":"API Reference","title":"UnitaryTransformations.Subspace","text":"Subspace(constraints...)\n\nDefine a low-energy subspace P by specifying constraints on operators.\n\nExamples\n\n# Spin-down subspace\nP = Subspace(œÉz() => -1)\n\n# Vacuum subspace (zero bosons)\nP = Subspace(a'()*a() => 0)\n\n# Product state: spin-down AND zero bosons\nP = Subspace(œÉz() => -1, a'()*a() => 0)\n\n# Indexed systems\nP = Subspace(œÉz(:i) => -1)  # All spins down\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitaryTransformations.OperatorConstraint","page":"API Reference","title":"UnitaryTransformations.OperatorConstraint","text":"OperatorConstraint\n\nA single constraint defining a sector: an operator and its eigenvalue in that sector.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitaryTransformations.decompose","page":"API Reference","title":"UnitaryTransformations.decompose","text":"decompose(H::QuExpr, P::Subspace)\n\nDecompose H into diagonal and off-diagonal parts with respect to subspace P.\n\nReturns (Hd, Hod) where:\n\nH_d is the block-diagonal part\nH_od is the off-block-diagonal part\nH = Hd + Hod\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.diagonal_part","page":"API Reference","title":"UnitaryTransformations.diagonal_part","text":"diagonal_part(H::QuExpr, P::Subspace)\n\nExtract the block-diagonal part of H with respect to subspace P. This includes terms that preserve P (P¬∑H¬∑P) and terms that preserve Q (Q¬∑H¬∑Q).\n\nNote: Terms classified as MIXED (like œÉx when not using œÉpm mode) are skipped. For proper handling, ensure Hamiltonians are expressed in the œÉ¬± basis.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.off_diagonal_part","page":"API Reference","title":"UnitaryTransformations.off_diagonal_part","text":"off_diagonal_part(H::QuExpr, P::Subspace)\n\nExtract the off-block-diagonal part of H with respect to subspace P. This includes terms that couple P to Q (P¬∑H¬∑Q + Q¬∑H¬∑P).\n\nNote: MIXED terms (like œÉx in œÉz basis, or off-diagonal Lie algebra generators) are included in the off-diagonal part since they contain off-diagonal components that couple different subspaces.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.is_diagonal","page":"API Reference","title":"UnitaryTransformations.is_diagonal","text":"is_diagonal(expr::QuExpr, P::Subspace)\n\nCheck if an expression is purely block-diagonal with respect to subspace P.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.is_off_diagonal","page":"API Reference","title":"UnitaryTransformations.is_off_diagonal","text":"is_off_diagonal(expr::QuExpr, P::Subspace)\n\nCheck if an expression is purely off-block-diagonal with respect to subspace P.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.solve_for_generator","page":"API Reference","title":"UnitaryTransformations.solve_for_generator","text":"solve_for_generator(H_d::QuExpr, V_od::QuExpr, P::Subspace)\n\nSolve [S, Hd] = -Vod for the generator S.\n\nThis is the core equation in Schrieffer-Wolff: we need to find S such that the commutator with the diagonal part cancels the off-diagonal perturbation.\n\nThe fundamental solution in the energy eigenbasis is:     S{ij} = V{ij} / (Ei - Ej)\n\nTwo methods are automatically selected based on operator types:\n\nEigenoperator method (TLS, bosons, N-level transitions): For operators O  where [H_d, O] = Œµ¬∑O, the solution is S = V/Œµ directly.\nMatrix-element method (SU(N) Lie algebras): Convert to the Cartan-Weyl  (transition) basis where operators ARE eigenoperators, apply S{ij} = V{ij}/(Ei - Ej), then convert back.\n\nUses Symbolics.jl for proper symbolic division, allowing denominators like (Œî - œâ).\n\nArguments\n\nH_d: The diagonal (unperturbed) Hamiltonian\nV_od: The off-diagonal perturbation to be eliminated\nP: The subspace defining the block structure\n\nReturns\n\nS: The generator of the transformation\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.solve_for_generator_eigenoperator","page":"API Reference","title":"UnitaryTransformations.solve_for_generator_eigenoperator","text":"solve_for_generator_eigenoperator(H_d::QuExpr, V_od::QuExpr, P::Subspace)\n\nSolve [S, Hd] = -Vod using the eigenoperator method.\n\nThis method works for operators O where [H_d, O] = Œµ¬∑O (eigenoperators of the  adjoint action). The solution is simply S = V/Œµ.\n\nExamples of eigenoperators:\n\nœÉ¬± for TLS with H_d ‚àù œÉz: [œÉz, œÉ¬±] = ¬±2œÉ¬±\na, a‚Ä† for bosons with H_d ‚àù a‚Ä†a: [a‚Ä†a, a] = -a, [a‚Ä†a, a‚Ä†] = a‚Ä†\n|i‚ü©‚ü®j| for N-level with diagonal Hd: [Hd, |i‚ü©‚ü®j|] = (Ei - Ej)|i‚ü©‚ü®j|\n\nFor each term in Vod, the corresponding term in S is Vterm / Œµ.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.solve_for_generator_lie","page":"API Reference","title":"UnitaryTransformations.solve_for_generator_lie","text":"solve_for_generator_lie(H_d::QuExpr, V_od::QuExpr, N::Int, generators::Tuple; \n                        algebra_id=SU3_ALGEBRA_ID)\n\nSolve [S, Hd] = -Vod for the generator S using the matrix-element method.\n\nThis approach works for any SU(N) Lie algebra by:\n\nComputing energy eigenvalues Ei from Hd\nConverting V_od to Cartan-Weyl basis (transition operators |i‚ü©‚ü®j|)\nApplying the fundamental formula: S{ij} = V{ij} / (Ei - Ej)\nConverting S back to Gell-Mann basis\n\nThe key insight is that transition operators |i‚ü©‚ü®j| ARE eigenoperators:     [Hd, |i‚ü©‚ü®j|] = (Ei - E_j)|i‚ü©‚ü®j|\n\nArguments\n\nH_d: The diagonal Hamiltonian (in diagonal generators only)\nV_od: The off-diagonal perturbation to be eliminated\nN: Dimension of the representation (2 for SU(2), 3 for SU(3))\ngenerators: Tuple of SU(N) generators (from su_generators)\nalgebra_id: The algebra identifier (default: SU3ALGEBRAID)\n\nReturns\n\nS: The generator of the transformation\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.compute_energy_denominator","page":"API Reference","title":"UnitaryTransformations.compute_energy_denominator","text":"compute_energy_denominator(H_d::QuExpr, term::QuTerm, P::Subspace)\n\nCompute the energy denominator for a given off-diagonal term.\n\nFor an off-diagonal operator O, computes Œµ where [Hd, O] = Œµ¬∑O. This is the energy difference Ei - E_j for the transition that O represents.\n\nReturns the energy denominator as a Symbolics Num expression, or nothing if the operator commutes with H_d (degenerate case).\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.compute_energy_eigenvalues","page":"API Reference","title":"UnitaryTransformations.compute_energy_eigenvalues","text":"compute_energy_eigenvalues(H_d::QuExpr, N::Int, algebra_id::UInt16)\n\nCompute energy eigenvalues for an N-level system from a diagonal Hamiltonian expressed in terms of Lie algebra generators.\n\nFor SU(N), the diagonal generators (Cartan subalgebra) have known eigenvalues. This function extracts the coefficients from H_d and computes E·µ¢ for each state.\n\nReturns a vector of symbolic expressions [E‚ÇÅ, E‚ÇÇ, ..., E‚Çô].\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.detect_lie_algebra_system","page":"API Reference","title":"UnitaryTransformations.detect_lie_algebra_system","text":"detect_lie_algebra_system(V_od::QuExpr)\n\nDetect if V_od contains Lie algebra generators and return information about the algebra.\n\nReturns nothing if no Lie algebra operators found, or a NamedTuple with:\n\nN: dimension of the algebra (2 for SU(2), 3 for SU(3))\nalgebra_id: the UInt16 algebra identifier\nname: the generator name (e.g., :Œª)\ninds: the indices tuple\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.project_to_subspace","page":"API Reference","title":"UnitaryTransformations.project_to_subspace","text":"project_to_subspace(H::QuExpr, P::Subspace)\n\nProject an operator onto the subspace P.\n\nThis replaces diagonal operators by their eigenvalues in P:\n\nœÉz ‚Üí eigenvalue (e.g., -1 for spin down)\nœÉ‚Å∫œÉ‚Åª ‚Üí 0 for spin down, 1 for spin up\na‚Ä†a ‚Üí eigenvalue (e.g., 0 for vacuum)\n\nAnd removes any remaining off-diagonal terms.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.bch_transform","page":"API Reference","title":"UnitaryTransformations.bch_transform","text":"bch_transform(S::QuExpr, A::QuExpr; order::Int=4)\n\nCompute e^S A e^{-S} using the BCH formula to the specified order.\n\nThis computes the adjoint action of e^S on an operator A:     e^S A e^{-S} = A + [S,A] + (1/2!)[S,[S,A]] + (1/3!)[S,[S,[S,A]]] + ...\n\nArguments\n\nS: The generator (typically anti-Hermitian: S‚Ä† = -S)\nA: The operator to transform (e.g., a Hamiltonian)\norder: Number of nested commutators to include (default: 4)\n\nExample\n\nusing QuantumAlgebra, UnitaryTransformations, Symbolics\n@variables g Œî\n\n# Generator from SW transformation\nS = (g/Œî) * (a'()*œÉm() - a()*œÉp())\n\n# Transform the Hamiltonian\nH = Œî/2 * œÉz() + g * (a'()*œÉm() + a()*œÉp())\nH_transformed = bch_transform(S, H; order=2)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.commutator_series","page":"API Reference","title":"UnitaryTransformations.commutator_series","text":"commutator_series(S::QuExpr, H::QuExpr, order::Int)\n\nCompute the BCH expansion of e^S H e^{-S} to the given order.\n\ne^S H e^{-S} = Œ£‚Çô (1/n!) [S, [S, [..., [S, H]...]]]  (n nested commutators)\n\nThe expansion is truncated at order nested commutators.\n\nArguments\n\nS: The generator of the unitary transformation (anti-Hermitian: S‚Ä† = -S)\nH: The operator to transform\norder: Maximum number of nested commutators to include\n\nReturns\n\nThe transformed operator as a QuExpr\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.nested_commutator","page":"API Reference","title":"UnitaryTransformations.nested_commutator","text":"nested_commutator(S::QuExpr, H::QuExpr, n::Int)\n\nCompute the n-fold nested commutator [S, [S, [..., [S, H]...]]] with S appearing n times.\n\nn=0 returns H\nn=1 returns [S, H]\nn=2 returns [S, [S, H]]\netc.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.simplify_coefficients","page":"API Reference","title":"UnitaryTransformations.simplify_coefficients","text":"simplify_coefficients(expr::QuExpr)\n\nSimplify all Symbolics coefficients in a QuExpr. Returns a new QuExpr with simplified coefficients.\n\nUses simplify_fractions which is much faster than full simplify for the rational expressions that arise in Schrieffer-Wolff.\n\nNote: Parallelization was attempted but SymbolicUtils/Symbolics.jl has thread-safety issues that cause race conditions during simplification. The serial version is used for correctness.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.substitute_values","page":"API Reference","title":"UnitaryTransformations.substitute_values","text":"substitute_values(expr::QuExpr, values::Dict{Symbol, Number})\n\nSubstitute numerical values for symbolic parameters in a QuExpr.\n\nArguments\n\nexpr: A QuExpr with symbolic coefficients\nvalues: Dict mapping parameter symbols to numerical values\n\nExample\n\nH_P = result.H_P\nvalues = Dict(:g => 0.1, :Œî => 1.0)\nH_numeric = substitute_values(H_P, values)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.extract_coefficient","page":"API Reference","title":"UnitaryTransformations.extract_coefficient","text":"extract_coefficient(expr::QuExpr, target_ops::QuExpr)\n\nExtract the coefficient of a specific operator structure from a QuExpr.\n\nArguments\n\nexpr: The full QuExpr to search\ntarget_ops: The operator structure to match (e.g., a'()*a())\n\nReturns\n\nThe coefficient (Num or Number) if found, nothing otherwise\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.collect_terms","page":"API Reference","title":"UnitaryTransformations.collect_terms","text":"collect_terms(expr::QuExpr)\n\nCollect and display all terms in a QuExpr with their simplified coefficients. Returns a vector of (operatorstring, simplifiedcoefficient) pairs.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.to_latex","page":"API Reference","title":"UnitaryTransformations.to_latex","text":"to_latex(expr::QuExpr; simplify_coeff::Bool=true)\n\nConvert a QuExpr to a LaTeX string with simplified coefficients.\n\nArguments\n\nexpr: The quantum expression to convert\nsimplify_coeff: Whether to simplify coefficients first (default: true)\n\nReturns\n\nA LaTeX string representation of the expression.\n\nExample\n\nH = Œî/2 * œÉz() + g * (a'() * œÉm() + a() * œÉp())\nprintln(to_latex(H))\n\n\n\n\n\nto_latex(result::NamedTuple; simplify_coeff::Bool=true)\n\nConvert a Schrieffer-Wolff result to LaTeX strings.\n\nReturns\n\nA NamedTuple with LaTeX strings for each component:\n\nH_eff: The effective Hamiltonian\nS: The generator\nH_P: The projected Hamiltonian\n\nExample\n\nresult = schrieffer_wolff(H, P; order=2)\nlatex_result = to_latex(result)\nprintln(latex_result.H_P)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.print_latex","page":"API Reference","title":"UnitaryTransformations.print_latex","text":"print_latex(expr::QuExpr; name::String=\"\", display::Bool=true, simplify_coeff::Bool=true)\n\nPrint a QuExpr as LaTeX, optionally wrapped in display math environment.\n\nArguments\n\nexpr: The quantum expression to print\nname: Optional name to show (e.g., \"H_{eff}\")\ndisplay: If true, wrap in \\[ ... \\] for display math\nsimplify_coeff: Whether to simplify coefficients first\n\nExample\n\nprint_latex(result.H_P; name=\"H_P\")\n# Output: H_P = - \\frac{1}{2} \\Delta + ...\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.show_result","page":"API Reference","title":"UnitaryTransformations.show_result","text":"show_result(result::NamedTuple; display::Bool=false, simplify_coeff::Bool=true)\n\nPretty-print all components of a Schrieffer-Wolff result in LaTeX.\n\nArguments\n\nresult: The result from schrieffer_wolff\ndisplay: If true, wrap each in display math environment\nsimplify_coeff: Whether to simplify coefficients\n\nExample\n\nresult = schrieffer_wolff(H, P; order=2)\nshow_result(result)\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.param_to_symbolic","page":"API Reference","title":"UnitaryTransformations.param_to_symbolic","text":"param_to_symbolic(p::Param)\n\nConvert a QuantumAlgebra Param to a Symbolics variable. Caches variables to ensure the same param always maps to the same variable.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.symbolic_coefficient","page":"API Reference","title":"UnitaryTransformations.symbolic_coefficient","text":"symbolic_coefficient(term::QuTerm, coeff::Number)\n\nConvert a QuTerm's coefficient (Number + Params) to a single Symbolics expression. Handles both real and complex coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitaryTransformations.clear_param_cache!","page":"API Reference","title":"UnitaryTransformations.clear_param_cache!","text":"clear_param_cache!()\n\nClear the parameter to Symbolics variable cache. Useful when starting a new calculation with fresh variables.\n\n\n\n\n\n","category":"function"},{"location":"theory/#theory","page":"Theory","title":"Theory","text":"This section provides the mathematical background for the unitary transformations implemented in this package.","category":"section"},{"location":"theory/#Unitary-Transformations-in-Quantum-Mechanics","page":"Theory","title":"Unitary Transformations in Quantum Mechanics","text":"A unitary transformation maps a Hamiltonian H to a new Hamiltonian tildeH via:\n\ntildeH = U H U^dagger\n\nwhere U is a unitary operator (U^dagger U = mathbb1). The physics is unchanged‚Äîthe eigenvalues are preserved‚Äîbut the representation may be simpler or more convenient.\n\nWhen U = e^S for some anti-Hermitian generator S (i.e., S^dagger = -S), the transformed Hamiltonian can be expanded using the Baker-Campbell-Hausdorff (BCH) formula:\n\ne^S H e^-S = H + S H + frac12S S H + frac13S S S H + cdots\n\nThis infinite series becomes tractable when S is small (perturbative) or when the series terminates after a finite number of terms.\n\n","category":"section"},{"location":"theory/#sw_transformation","page":"Theory","title":"Schrieffer-Wolff Transformation","text":"The Schrieffer-Wolff (SW) transformation is a perturbative method for block-diagonalizing Hamiltonians with well-separated energy scales. It was introduced by Schrieffer and Wolff in 1966 to derive the Kondo exchange interaction from the Anderson impurity model.","category":"section"},{"location":"theory/#The-Problem","page":"Theory","title":"The Problem","text":"Consider a Hamiltonian of the form:\n\nH = H_0 + V\n\nwhere:\n\nH_0 is the unperturbed Hamiltonian with known eigenstates grouped into low-energy (P) and high-energy (Q) sectors\nV is a perturbation that couples the P and Q sectors\n\nWe want to find an effective Hamiltonian H_texteff that:\n\nActs only within the low-energy sector P\nCaptures the effects of V to a given order in perturbation theory","category":"section"},{"location":"theory/#The-Transformation","page":"Theory","title":"The Transformation","text":"We seek a unitary U = e^S such that the transformed Hamiltonian:\n\nH_texteff = e^S H e^-S\n\nis block-diagonal with respect to the P and Q subspaces. This means H_texteff has no matrix elements connecting P and Q.","category":"section"},{"location":"theory/#Determining-the-Generator","page":"Theory","title":"Determining the Generator","text":"Decompose the Hamiltonian and generator into block-diagonal and off-block-diagonal parts:\n\nH = H_d + V_od quad S = S_od\n\nwhere:\n\nH_d = P H P + Q H Q (block-diagonal)\nV_od = P H Q + Q H P (off-block-diagonal)\nS_od is purely off-block-diagonal (anti-Hermitian)\n\nThe generator equation at first order is:\n\nS H_d = -V_od\n\nThis is the fundamental equation that determines S. It states that the commutator of S with the diagonal Hamiltonian must cancel the off-diagonal perturbation.","category":"section"},{"location":"theory/#Solving-the-Generator-Equation","page":"Theory","title":"Solving the Generator Equation","text":"For operators O that are eigenoperators of the adjoint action of H_d‚Äîmeaning H_d O = varepsilon cdot O for some energy varepsilon‚Äîthe solution is:\n\nS = sum_alpha fracV_alphavarepsilon_alpha\n\nwhere V_alpha are the components of V_od and varepsilon_alpha are the corresponding energy denominators.\n\nExample: For a two-level system with H_d = fracDelta2sigma_z and V_od = gsigma^+:\n\nsigma_z sigma^+ = 2sigma^+, so H_d sigma^+ = Deltasigma^+\nTherefore S = fracgDeltasigma^+ (plus Hermitian conjugate for the sigma^- term)","category":"section"},{"location":"theory/#The-Effective-Hamiltonian","page":"Theory","title":"The Effective Hamiltonian","text":"Using the BCH expansion:\n\nH_texteff = H_d + frac12S V_od + O(V^3)\n\nThe key second-order contribution is:\n\nH^(2) = frac12S V_od\n\nThis generates effective interactions within the low-energy sector that arise from virtual transitions to high-energy states.","category":"section"},{"location":"theory/#Physical-Interpretation","page":"Theory","title":"Physical Interpretation","text":"The SW transformation captures the physics of virtual processes:\n\nThe system starts in the low-energy sector P\nThe perturbation V virtually excites it to high-energy sector Q\nThe system returns to P via another application of V\n\nThis virtual excitation costs energy Delta E and contributes to the effective Hamiltonian as sim V^2Delta E.","category":"section"},{"location":"theory/#Order-by-Order-Expansion","page":"Theory","title":"Order-by-Order Expansion","text":"At higher orders, the SW transformation proceeds iteratively:\n\nOrder Contribution Energy dependence\n0 H_d Original diagonal\n2 frac12S_1 V sim g^2Delta\n3 frac12S_1 S_1 H_d + S_2 V sim g^3Delta^2\n4 Higher nested commutators sim g^4Delta^3\n\nEach order adds terms suppressed by additional powers of gDelta.\n\n","category":"section"},{"location":"theory/#Eigenoperator-Method","page":"Theory","title":"Eigenoperator Method","text":"This package implements two methods for solving the generator equation. The eigenoperator method works for operators that satisfy:\n\nH_d O = varepsilon cdot O\n\nSuch operators are called eigenoperators of the Liouvillian mathcalL_H_d(cdot) = H_d cdot.","category":"section"},{"location":"theory/#Examples-of-Eigenoperators","page":"Theory","title":"Examples of Eigenoperators","text":"System Operator Eigenvalue\nTLS: H_d = fracDelta2sigma_z sigma^+ +Delta\n sigma^- -Delta\nCavity: H_d = omega a^dagger a a^dagger +omega\n a -omega\nN-level: H_d = sum_i E_i vert iranglelangle ivert vert iranglelangle jvert E_i - E_j\n\nFor these operators, the generator is simply:\n\nS = fracOvarepsilon","category":"section"},{"location":"theory/#Composite-Operators","page":"Theory","title":"Composite Operators","text":"Products of eigenoperators are also eigenoperators with additive eigenvalues:\n\nH_d O_1 O_2 = (varepsilon_1 + varepsilon_2) O_1 O_2\n\nExample: For the Jaynes-Cummings interaction a^dagger sigma^-:\n\nH_d a^dagger sigma^- = (omega_c - Delta) a^dagger sigma^-\nEnergy denominator: omega_c - Delta (the detuning)\n\n","category":"section"},{"location":"theory/#Matrix-Element-Method-for-Lie-Algebras","page":"Theory","title":"Matrix-Element Method for Lie Algebras","text":"For SU(N) systems expressed in the Gell-Mann basis, the generators are not eigenoperators of the diagonal Hamiltonian. For example:\n\nlambda_8 lambda_2 neq c cdot lambda_2\n\nInstead, the commutator produces a linear combination of generators.","category":"section"},{"location":"theory/#Cartan-Weyl-Basis","page":"Theory","title":"Cartan-Weyl Basis","text":"The solution is to work in the Cartan-Weyl basis, where the off-diagonal generators are replaced by transition operators:\n\nGell-Mann Cartan-Weyl\nlambda_1 lambda_4 E_12 = vert 1ranglelangle 2vert, E_21 = vert 2ranglelangle 1vert\nlambda_2 lambda_5 E_13 = vert 1ranglelangle 3vert, E_31 = vert 3ranglelangle 1vert\nlambda_3 lambda_6 E_23 = vert 2ranglelangle 3vert, E_32 = vert 3ranglelangle 2vert\n\nThe transition operators are eigenoperators:\n\nH_d vert iranglelangle jvert = (E_i - E_j)vert iranglelangle jvert","category":"section"},{"location":"theory/#Algorithm","page":"Theory","title":"Algorithm","text":"Compute energy eigenvalues E_i from the diagonal Hamiltonian\nConvert V_od from Gell-Mann to Cartan-Weyl basis\nApply inverse Liouvillian: S_ij = V_ij  (E_i - E_j)\nConvert S back to Gell-Mann basis\n\nThis is implemented in solve_for_generator_lie().\n\n","category":"section"},{"location":"theory/#Energy-Denominators","page":"Theory","title":"Energy Denominators","text":"The energy denominators in SW transformations have important physical meaning:","category":"section"},{"location":"theory/#Resonance-Condition","page":"Theory","title":"Resonance Condition","text":"When an energy denominator approaches zero (varepsilon to 0), the perturbation theory breaks down. This indicates a resonance where the two sectors are no longer well-separated.","category":"section"},{"location":"theory/#Example:-Dispersive-Regime","page":"Theory","title":"Example: Dispersive Regime","text":"In circuit QED, the Jaynes-Cummings Hamiltonian has energy denominator Delta = omega_q - omega_c. The dispersive approximation is valid when:\n\ng ll Delta\n\nThe effective Hamiltonian contains the dispersive shift:\n\nchi = -fracg^2Delta\n\nThis diverges as Delta to 0 (resonance), signaling the breakdown of the perturbative treatment.\n\n","category":"section"},{"location":"theory/#Comparison-with-Other-Methods","page":"Theory","title":"Comparison with Other Methods","text":"","category":"section"},{"location":"theory/#vs.-L√∂wdin-Partitioning","page":"Theory","title":"vs. L√∂wdin Partitioning","text":"L√∂wdin partitioning (also called quasi-degenerate perturbation theory) achieves the same goal but works directly with the Hamiltonian matrix rather than through a unitary transformation. SW provides the explicit generator S, which can be useful for understanding the transformation and computing other observables.","category":"section"},{"location":"theory/#vs.-Adiabatic-Elimination","page":"Theory","title":"vs. Adiabatic Elimination","text":"Adiabatic elimination assumes fast variables equilibrate instantly. SW is more systematic and provides higher-order corrections, but requires a perturbative expansion.","category":"section"},{"location":"theory/#vs.-Numerical-Diagonalization","page":"Theory","title":"vs. Numerical Diagonalization","text":"Numerical methods give exact eigenvalues but not analytical expressions. SW produces symbolic results like g^2Delta that reveal the parameter dependence and scaling.\n\n","category":"section"},{"location":"theory/#References","page":"Theory","title":"References","text":"J. R. Schrieffer and P. A. Wolff, \"Relation between the Anderson and Kondo Hamiltonians,\" Phys. Rev. 149, 491 (1966).\nS. Bravyi, D. P. DiVincenzo, and D. Loss, \"Schrieffer-Wolff transformation for quantum many-body systems,\" Ann. Phys. 326, 2793 (2011).\nC. Cohen-Tannoudji, J. Dupont-Roc, and G. Grynberg, Atom-Photon Interactions (Wiley, 1998), Chapter 3.\nM. Wagner, Unitary Transformations in Solid State Physics (North-Holland, 1986).","category":"section"},{"location":"examples/#examples","page":"Examples","title":"Examples","text":"This page presents complete physics examples demonstrating the Schrieffer-Wolff transformation. Each example shows the LaTeX output for easy use in publications.","category":"section"},{"location":"examples/#Jaynes-Cummings:-Dispersive-Regime","page":"Examples","title":"Jaynes-Cummings: Dispersive Regime","text":"The Jaynes-Cummings model describes a two-level atom coupled to a single cavity mode:\n\nH = omega_c a^dagger a + fracomega_q2sigma_z + g(a^daggersigma^- + asigma^+)\n\nIn the dispersive regime (Delta = omega_q - omega_c gg g), the Schrieffer-Wolff transformation yields an effective Hamiltonian with a state-dependent frequency shift.\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\nQuantumAlgebra.use_œÉpm(true)\n\n@variables Œî g  # Œî = detuning, g = coupling\n\n# Hamiltonian (in rotating frame)\nH = Œî/2 * œÉz() + g * (a'()*œÉm() + a()*œÉp())\n\n# Ground state subspace\nP = Subspace(œÉz() => -1)\n\n# Transform and display results\nresult = schrieffer_wolff(H, P; order=2)\nshow_result(result)\n\nGenerator:\n\nS = frac-g2Delta a^dagger sigma^- + fracg2Delta sigma^+ a\n\nEffective Hamiltonian:\n\nH_texteff = -fracDelta2 - fracg^2Delta a^dagger a + fracg^2 + Delta^2Delta sigma^+ sigma^- + frac2g^2Delta a^dagger sigma^+ sigma^- a\n\nProjected to subspace P (qubit ground state):\n\nH_P = -fracDelta2 - fracg^2Delta a^dagger a","category":"section"},{"location":"examples/#Physical-Interpretation","page":"Examples","title":"Physical Interpretation","text":"The effective Hamiltonian contains:\n\nDispersive shift: chi = -g^2Delta ‚Äî cavity frequency shifts when qubit is in ground state\nAC Stark shift: Qubit frequency shifts with photon number\n\nThis is the basis for qubit readout in circuit QED!","category":"section"},{"location":"examples/#Extracting-Parameters","page":"Examples","title":"Extracting Parameters","text":"œá = extract_coefficient(result.H_P, a'()*a())\nprintln(to_latex(œá))  # Output: \\frac{-g^{2}}{\\Delta}\n\n# Numerical evaluation\nH_num = substitute_values(result.H_P, Dict(:g => 0.1, :Œî => 1.0))\n# œá = -0.01, matching -g¬≤/Œî\n\n","category":"section"},{"location":"examples/#Two-Level-System-with-Transverse-Field","page":"Examples","title":"Two-Level System with Transverse Field","text":"A qubit in longitudinal and transverse magnetic fields:\n\nH = fracDelta2sigma_z + varepsilonsigma_x\n\nThis textbook problem has an exact solution, making it perfect for verification.\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\nQuantumAlgebra.use_œÉpm(true)\n\n@variables Œî Œµ\n\nH = Œî/2 * œÉz() + Œµ * (œÉp() + œÉm())\nP = Subspace(œÉz() => -1)\n\nresult = schrieffer_wolff(H, P; order=2)\nprint_latex(result.H_P; name=\"H_P\")\n\nOutput:\n\nH_P = -fracDelta2 - fracvarepsilon^2Delta","category":"section"},{"location":"examples/#Comparison-with-Exact-Solution","page":"Examples","title":"Comparison with Exact Solution","text":"The exact ground state energy is:\n\nE_- = -sqrtfracDelta^24 + varepsilon^2 approx -fracDelta2 - fracvarepsilon^2Delta + O(varepsilon^4)\n\nThe SW result matches the perturbation expansion exactly!\n\nvarepsilonDelta Exact SW (2nd order) Error\n0.01 -0.50005 -0.5001 0.00%\n0.05 -0.50125 -0.5025 0.00%\n0.10 -0.50499 -0.51 0.02%\n0.20 -0.51980 -0.54 0.28%\n\n","category":"section"},{"location":"examples/#Rabi-Model:-Bloch-Siegert-Shift","page":"Examples","title":"Rabi Model: Bloch-Siegert Shift","text":"The full Rabi model includes counter-rotating terms neglected in the rotating-wave approximation:\n\nH = omega a^dagger a + fracDelta2sigma_z + g(sigma^+ + sigma^-)(a + a^dagger)\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\nQuantumAlgebra.use_œÉpm(true)\n\n@variables œâ Œî g\n\nH = œâ * a'()*a() + Œî/2 * œÉz() + g * (œÉp() + œÉm()) * (a() + a'())\nP = Subspace(œÉz() => -1)\n\nresult = schrieffer_wolff(H, P; order=2)\nprint_latex(result.H_P; name=\"H_P\")\n\nOutput:\n\nH_P = -fracDelta2 + omega a^dagger a - fracg^2Delta - omega a^dagger a - fracg^2Delta + omega a^dagger a + fracg^2Delta + omega - fracg^2Delta + omega (a^dagger)^2 - fracg^2Delta + omega a^2","category":"section"},{"location":"examples/#Physical-Interpretation-2","page":"Examples","title":"Physical Interpretation","text":"Compared to Jaynes-Cummings, the full Rabi model produces:\n\nJC dispersive shift: -g^2(Delta - omega) from rotating terms\nBloch-Siegert shift: -g^2(Delta + omega) from counter-rotating terms\nSqueezing terms: a^2 and (a^dagger)^2 that squeeze the cavity field\n\nThe total dispersive shift combines both contributions:\n\nchi_texttotal = -fracg^2Delta - omega - fracg^2Delta + omega\n\n","category":"section"},{"location":"examples/#N-Level-Atom-in-a-Cavity","page":"Examples","title":"N-Level Atom in a Cavity","text":"For atoms with more than two levels, use nlevel_ops:\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# 5-level atom: œÉ[i,j] = |i‚ü©‚ü®j|\nœÉ5 = nlevel_ops(5, :q)\n\nœâ = [Symbolics.variable(Symbol(\"œâ\", i)) for i in 1:5]\n@variables œâc g\n\n# Atom + cavity + dipole coupling |1‚ü©‚Üî|3‚ü©\nH = sum(œâ[i] * œÉ5[i,i] for i in 1:5) + \n    œâc * a'()*a() + \n    g * (œÉ5[1,3] * a'() + œÉ5[3,1] * a())\n\n# Zero-photon subspace\nP = Subspace(a'()*a() => 0)\n\nresult = schrieffer_wolff(H, P; order=2)\nshow_result(result)\n\nGenerator:\n\nS = fracgomega_1 - omega_3 - omega_c 1ranglelangle 3  a^dagger + fracgomega_3 - omega_1 + omega_c 3ranglelangle 1  a","category":"section"},{"location":"examples/#Physical-Interpretation-3","page":"Examples","title":"Physical Interpretation","text":"Dispersive shift: chi_13 = g^2(omega_1 - omega_3 + omega_c)\nAC Stark shifts on levels 1 and 3\nOther levels (2, 4, 5) appear only with bare energies\n\n","category":"section"},{"location":"examples/#Three-Level-Lambda-System","page":"Examples","title":"Three-Level Lambda System","text":"For systems with SU(N) symmetry, use su_generators:\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# Gell-Mann matrices for SU(3)\nŒª = su_generators(3, :Œª)\n\n@variables Œî Œ©‚ÇÅ Œ©‚ÇÇ\n\n# Lambda system\nH = Œî * Œª[8] + Œ©‚ÇÅ * Œª[1] + Œ©‚ÇÇ * Œª[4]\n\nP = Subspace(Œª[8] => 1/sqrt(3))\n\nresult = schrieffer_wolff(H, P; order=2)\nshow_result(result)\n\nThe package automatically detects SU(3) and uses the matrix-element method.","category":"section"},{"location":"examples/#When-to-Use-SU(N)-vs-N-Level","page":"Examples","title":"When to Use SU(N) vs N-Level","text":"Approach Use When\nnlevel_ops Physical atoms, specific transitions\nsu_generators Systems with SU(N) symmetry\n\n","category":"section"},{"location":"examples/#Running-the-Examples","page":"Examples","title":"Running the Examples","text":"Complete example files are in the examples/ directory:\n\njulia --project examples/jaynes_cummings_dispersive.jl\njulia --project examples/two_level_system.jl\njulia --project examples/rabi_bloch_siegert.jl\njulia --project examples/three_level_atom.jl\n\n","category":"section"},{"location":"examples/#Tips","page":"Examples","title":"Tips","text":"Use show_result(result) to see all components in LaTeX\nUse to_latex(expr) to get a LaTeX string for any expression\nUse extract_coefficient(expr, op) to get specific parameters\nUse substitute_values(expr, Dict(...)) for numerical evaluation","category":"section"},{"location":"#UnitaryTransformations.jl","page":"Home","title":"UnitaryTransformations.jl","text":"A Julia package for performing symbolic unitary transformations on quantum Hamiltonians.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"Unitary transformations are essential tools in quantum mechanics for:\n\nSimplifying Hamiltonians by eliminating unwanted couplings\nDeriving effective theories that capture low-energy physics\nBlock-diagonalizing systems with separated energy scales\nChanging to more convenient representations (e.g., polaron frame)\n\nThis package provides symbolic implementations that produce analytical expressions rather than numerical results. For example, the dispersive shift in circuit QED is computed as -g¬≤/Œî, not as a floating-point number.","category":"section"},{"location":"#Available-Transformations","page":"Home","title":"Available Transformations","text":"Transformation Purpose Status\nSchrieffer-Wolff Block-diagonalize Hamiltonians, derive effective low-energy theories ‚úì Implemented\nLang-Firsov Eliminate linear electron-phonon coupling (polaron frame) Planned\nBogoliubov Diagonalize quadratic bosonic Hamiltonians Planned\nHolstein-Primakoff Map spin operators to bosonic operators Planned","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# Use œÉ¬± basis (recommended)\nQuantumAlgebra.use_œÉpm(true)\n\n# Define symbolic parameters\n@variables Œî g\n\n# Jaynes-Cummings Hamiltonian\nH = Œî/2 * œÉz() + g * (a'()*œÉm() + a()*œÉp())\n\n# Define the low-energy subspace\nP = Subspace(œÉz() => -1)  # qubit ground state\n\n# Perform Schrieffer-Wolff transformation\nresult = schrieffer_wolff(H, P; order=2)\n\n# The effective Hamiltonian\nprintln(result.H_P)\n# Output: -Œî/2 + (-g¬≤/Œî) a‚Ä†a","category":"section"},{"location":"#Supported-Quantum-Systems","page":"Home","title":"Supported Quantum Systems","text":"The package works with a variety of quantum systems provided by QuantumAlgebra.jl:\n\nSystem Operators Example\nTwo-level systems œÉx(), œÉy(), œÉz(), œÉp(), œÉm() Qubits, spin-1/2\nBosonic modes a(), a'() Cavities, phonons\nN-level atoms nlevel_ops(N, :name) Multi-level atoms\nSU(N) systems su_generators(N, :name) 3-level Œõ systems\nFermions f(:name), f'(:name) Electrons\n\nThese can be combined freely‚Äîfor example, an N-level atom coupled to a bosonic cavity.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/volkerkarle/UnitaryTransformations.jl\")\n\nDependencies (automatically installed):\n\nQuantumAlgebra.jl ‚Äî Symbolic quantum operator algebra\nSymbolics.jl ‚Äî Computer algebra system","category":"section"},{"location":"#Documentation-Structure","page":"Home","title":"Documentation Structure","text":"Pages = [\"theory.md\", \"tutorial.md\", \"examples.md\", \"api.md\"]\nDepth = 1","category":"section"},{"location":"#[Theory](@ref-theory)","page":"Home","title":"Theory","text":"Mathematical background on unitary transformations, including the Schrieffer-Wolff method and the Baker-Campbell-Hausdorff formula.","category":"section"},{"location":"#[Tutorial](@ref-tutorial)","page":"Home","title":"Tutorial","text":"Step-by-step guide to using the Schrieffer-Wolff transformation.","category":"section"},{"location":"#[Examples](@ref-examples)","page":"Home","title":"Examples","text":"Physics applications: Jaynes-Cummings, Rabi model, multi-level atoms.","category":"section"},{"location":"#[API-Reference](@ref-api)","page":"Home","title":"API Reference","text":"Complete function documentation.","category":"section"},{"location":"#Package-Philosophy","page":"Home","title":"Package Philosophy","text":"Symbolic over numeric: Results are analytical expressions that can be simplified, manipulated, and substituted.\nAutomatic method selection: The package chooses the optimal algorithm based on the operator types present.\nExtensible design: New transformations can be added as separate modules while sharing the infrastructure.\nVerified correctness: Extensive tests verify mathematical identities and compare with known results.","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"If you use this package in your research:\n\n@software{UnitaryTransformations.jl,\n  author = {Karle, Volker},\n  title = {UnitaryTransformations.jl: Symbolic Unitary Transformations for Quantum Hamiltonians},\n  url = {https://github.com/volkerkarle/UnitaryTransformations.jl},\n  year = {2025}\n}","category":"section"},{"location":"tutorial/#tutorial","page":"Tutorial","title":"Tutorial","text":"This tutorial walks through the Schrieffer-Wolff transformation step by step. For the mathematical background, see the Theory page.","category":"section"},{"location":"tutorial/#Overview","page":"Tutorial","title":"Overview","text":"The Schrieffer-Wolff (SW) transformation finds an effective Hamiltonian that acts within a chosen subspace by perturbatively eliminating couplings to other subspaces. This is useful when:\n\nYou have a system with well-separated energy scales\nYou want to derive an effective low-energy theory\nYou need analytical expressions for perturbative corrections","category":"section"},{"location":"tutorial/#Step-1:-Set-Up-the-System","page":"Tutorial","title":"Step 1: Set Up the System","text":"Let's work with a concrete example: a two-level system (qubit) coupled to a harmonic oscillator (the Jaynes-Cummings model).\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# Use œÉ¬± basis - important for SW to work correctly with spins\nQuantumAlgebra.use_œÉpm(true)\n\n# Define symbolic parameters\n@variables Œî g  # Œî = qubit-oscillator detuning, g = coupling strength\n\n# Jaynes-Cummings Hamiltonian (in rotating frame)\nH = Œî/2 * œÉz() + g * (a'()*œÉm() + a()*œÉp())\n\nThe Hamiltonian describes:\n\nA qubit with splitting Delta (the sigma_z term)\nCoupling to an oscillator mode (the a^dagger sigma^- and a sigma^+ terms)","category":"section"},{"location":"tutorial/#Step-2:-Define-the-Subspace","page":"Tutorial","title":"Step 2: Define the Subspace","text":"We need to specify which states belong to the low-energy subspace P. For this example, we choose the qubit ground state:\n\n# P = states where œÉz = -1 (qubit in ground state |g‚ü©)\nP = Subspace(œÉz() => -1)\n\nThe Subspace type specifies expectation values of operators in the subspace. Here, we say that in subspace P, the operator sigma_z has eigenvalue -1.","category":"section"},{"location":"tutorial/#Multiple-Constraints","page":"Tutorial","title":"Multiple Constraints","text":"For more complex systems, you can specify multiple constraints:\n\n# Subspace with qubit ground state AND zero photons\nP = Subspace(œÉz() => -1, a'()*a() => 0)","category":"section"},{"location":"tutorial/#Step-3:-Understand-the-Decomposition","page":"Tutorial","title":"Step 3: Understand the Decomposition","text":"The SW transformation requires splitting H into diagonal and off-diagonal parts with respect to P:\n\nH_d, V_od = decompose(H, P)\n\nprintln(\"Diagonal:     \", H_d)\nprintln(\"Off-diagonal: \", V_od)\n\nOutput:\n\nDiagonal:     -0.5Œî + Œî œÉ‚Å∫œÉ‚Åª\nOff-diagonal: g a‚Ä†œÉ‚Åª + g a œÉ‚Å∫\n\nDiagonal (H_d): Operators that don't change the subspace (like sigma^+sigma^-, a^dagger a)\nOff-diagonal (V_od): Operators that connect P and Q subspaces (like sigma^+, sigma^-)","category":"section"},{"location":"tutorial/#Step-4:-Perform-the-Transformation","page":"Tutorial","title":"Step 4: Perform the Transformation","text":"Now apply the Schrieffer-Wolff transformation:\n\nresult = schrieffer_wolff(H, P; order=2)\n\nThis returns a named tuple with:\n\nresult.S - The generator of the unitary transformation e^S\nresult.H_eff - The block-diagonal effective Hamiltonian\nresult.H_P - The effective Hamiltonian projected onto subspace P","category":"section"},{"location":"tutorial/#Higher-Orders","page":"Tutorial","title":"Higher Orders","text":"You can go to higher orders for more accuracy:\n\nresult_4th = schrieffer_wolff(H, P; order=4)\n\nNote: Higher orders produce more complex expressions and take longer to compute.","category":"section"},{"location":"tutorial/#Step-5:-Analyze-the-Results","page":"Tutorial","title":"Step 5: Analyze the Results","text":"","category":"section"},{"location":"tutorial/#The-Generator","page":"Tutorial","title":"The Generator","text":"println(\"Generator S = \", result.S)\n# S = (g/Œî) a‚Ä†œÉ‚Åª + (-g/Œî) a œÉ‚Å∫\n\nThe generator S is anti-Hermitian (S^dagger = -S) and satisfies:\n\nS H_d = -V_od","category":"section"},{"location":"tutorial/#The-Effective-Hamiltonian","page":"Tutorial","title":"The Effective Hamiltonian","text":"# Collect and display all terms with simplified coefficients\nterms = collect_terms(result.H_eff)\nfor (op, coeff) in terms\n    println(\"  \", coeff, \"  \", op)\nend\n\nOutput:\n\n  -0.5Œî        ùüô\n  -(g¬≤)/Œî      a‚Ä†a\n  Œî + (g¬≤)/Œî   œÉ‚Å∫œÉ‚Åª\n  ...","category":"section"},{"location":"tutorial/#The-Projected-Hamiltonian","page":"Tutorial","title":"The Projected Hamiltonian","text":"For many applications, we only care about the subspace P:\n\nprintln(\"H_P = \", result.H_P)\n# H_P = -0.5Œî + (-(g¬≤)/Œî) a‚Ä†a\n\nThis is the dispersive Hamiltonian: the cavity frequency is shifted by -g^2Delta when the qubit is in the ground state!","category":"section"},{"location":"tutorial/#Step-6:-Extract-Physical-Parameters","page":"Tutorial","title":"Step 6: Extract Physical Parameters","text":"Use utility functions to extract specific coefficients:\n\n# Get the dispersive shift (coefficient of a‚Ä†a)\nœá = extract_coefficient(result.H_P, a'()*a())\nprintln(\"Dispersive shift œá = \", œá)\n# Output: -(g¬≤)/Œî","category":"section"},{"location":"tutorial/#Step-7:-Numerical-Evaluation","page":"Tutorial","title":"Step 7: Numerical Evaluation","text":"Substitute numerical values to get concrete numbers:\n\nH_numeric = substitute_values(result.H_P, Dict(:g => 0.1, :Œî => 1.0))\nprintln(\"H_P with g=0.1, Œî=1.0: \", H_numeric)","category":"section"},{"location":"tutorial/#Step-8:-LaTeX-Output","page":"Tutorial","title":"Step 8: LaTeX Output","text":"For publications and documentation, you can output results in LaTeX:\n\n# Convert a single expression to LaTeX\nprintln(to_latex(result.H_P))\n# Output: - \\frac{1}{2} \\Delta + \\frac{-g^{2}}{\\Delta} {a}^{\\dagger} {a}\n\n# Pretty-print with a name\nprint_latex(result.H_P; name=\"H_P\")\n# Output: H_P = - \\frac{1}{2} \\Delta + \\frac{-g^{2}}{\\Delta} {a}^{\\dagger} {a}\n\n# Show all components of the result\nshow_result(result)\n\nThe show_result function prints the generator S, effective Hamiltonian H_texteff, and projected Hamiltonian H_P in LaTeX format.","category":"section"},{"location":"tutorial/#Complete-Example","page":"Tutorial","title":"Complete Example","text":"Here's the full code:\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# Setup\nQuantumAlgebra.use_œÉpm(true)\n\n# Define symbolic parameters and Hamiltonian\n@variables Œî g\nH = Œî/2 * œÉz() + g * (a'()*œÉm() + a()*œÉp())\n\n# Define subspace and transform\nP = Subspace(œÉz() => -1)\nresult = schrieffer_wolff(H, P; order=2)\n\n# Analyze results\nprintln(\"Effective Hamiltonian in ground state subspace:\")\nfor (op, coeff) in collect_terms(result.H_P)\n    println(\"  \", coeff, \"  \", op)\nend\n\n# Extract dispersive shift\nœá = extract_coefficient(result.H_P, a'()*a())\nprintln(\"\\nDispersive shift: œá = \", œá)\nprintln(\"Expected: -g¬≤/Œî\")\n\n","category":"section"},{"location":"tutorial/#N-Level-Atoms","page":"Tutorial","title":"N-Level Atoms","text":"The package supports N-level atomic systems using QuantumAlgebra's nlevel_ops:\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# Create 5-level atom operators: œÉ[i,j] = |i‚ü©‚ü®j|\nœÉ5 = nlevel_ops(5, :q)\n\n# Define level energies and coupling\nœâ = [Symbolics.variable(Symbol(\"œâ\", i)) for i in 1:5]\n@variables œâc g\n\n# Hamiltonian: 5-level atom + cavity, coupling levels 1‚Üî3\nH = sum(œâ[i] * œÉ5[i,i] for i in 1:5) + \n    œâc * a'()*a() + \n    g * (œÉ5[1,3] * a'() + œÉ5[3,1] * a())\n\n# Zero-photon subspace\nP = Subspace(a'()*a() => 0)\n\nresult = schrieffer_wolff(H, P; order=2)\nprintln(\"Effective Hamiltonian:\")\nprintln(result.H_eff)\n\nThe result contains dispersive shifts and AC Stark corrections for all levels.\n\n","category":"section"},{"location":"tutorial/#SU(N)-Systems","page":"Tutorial","title":"SU(N) Systems","text":"For systems described by SU(N) Lie algebras, the package automatically detects and uses the matrix-element method:\n\nusing UnitaryTransformations\nusing QuantumAlgebra\nusing Symbolics\n\n# SU(3) generators (Gell-Mann matrices)\nŒª = su_generators(3, :Œª)\n\n@variables Œî œâ g\n\n# Three-level Lambda system\nH = Œî * Œª[8] + œâ * Œª[7] + g * Œª[2]\n\n# Subspace defined by Œª‚Çà eigenvalue\nP = Subspace(Œª[8] => 0.5)\n\n# Automatically uses matrix-element method for SU(3)\nresult = schrieffer_wolff(H, P; order=2)\n\n","category":"section"},{"location":"tutorial/#Key-Points","page":"Tutorial","title":"Key Points","text":"Always use QuantumAlgebra.use_œÉpm(true) for SW transformations with spins\nDefine subspace carefully - this determines what \"diagonal\" means\nUse collect_terms to see simplified coefficients\nThe physics is in the coefficients - extract them with extract_coefficient\nN-level and SU(N) systems are automatically handled with appropriate methods","category":"section"},{"location":"tutorial/#Next-Steps","page":"Tutorial","title":"Next Steps","text":"See Examples for complete physics applications\nSee Theory for mathematical details\nSee API Reference for function documentation","category":"section"}]
}
